{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"pages/contribute/","title":"Contribute","text":"<p>Here you have some questions that you may have about the development of the language.</p>"},{"location":"pages/contribute/#how-is-ryna-being-developed","title":"How is Ryna being developed?","text":"<p>Ryna is a passion project being developed by only a single programmer. The development cycle is rather chaotic, adding features as I feel like it and in the order I think is to be expected. Right now, there is no community around Ryna and I expect it to stay like this for a long time (and maybe this will not ever change), so there is no need to change my methodology.</p> <p>In the rare case that this message is no longer applicable, then I guess it would be time to use a more strict way to program new features and correct bugs. Only time will say.</p>"},{"location":"pages/contribute/#can-i-help","title":"Can I help?","text":"<p>Indeed! You can fork the project and try to solve some issues if you feel like it. I'm afraid that the code is not exactly well documented, but if you still want to ttry the help is greatly appreciated.</p>"},{"location":"pages/contribute/#can-i-propose-something","title":"Can I propose something?","text":"<p>Be my guest! Please, create an issue in the repository for any kind of doubt you have about the language and for any new feature you think it would be nice to have.</p>"},{"location":"pages/reference/functions/arrays/","title":"Arrays","text":""},{"location":"pages/reference/functions/arrays/#arr","title":"arr","text":"Overload Description <code>arr&lt;T&gt;() -&gt; Array&lt;'T&gt;</code>                  Creates an empty <code>Array&lt;'T&gt;</code>"},{"location":"pages/reference/functions/arrays/#reserve","title":"reserve","text":"Overload Description <code>reserve&lt;T&gt;(arr: @Array&lt;'T&gt;, size: Int) -&gt; ()</code>                  Allocates enough memory in <code>arr</code> to contain <code>size</code> elements"},{"location":"pages/reference/functions/arrays/#len","title":"len","text":"Overload Description <code>len&lt;T&gt;(arr: @Array&lt;'T&gt;) -&gt; Int</code>                  Returns the length of <code>arr</code>"},{"location":"pages/reference/functions/arrays/#capacity","title":"capacity","text":"Overload Description <code>capacity&lt;T&gt;(arr: @Array&lt;'T&gt;) -&gt; Int</code>                  Returns the allocated size inside of <code>arr</code>"},{"location":"pages/reference/functions/arrays/#push","title":"push","text":"Overload Description <code>push&lt;T&gt;(arr: @Array&lt;'T&gt;, elem: 'T) -&gt; ()</code>                  Appends <code>elem</code> to the end of <code>arr</code>"},{"location":"pages/reference/functions/arrays/#pop","title":"pop","text":"Overload Description <code>pop&lt;T&gt;(arr: @Array&lt;'T&gt;) -&gt; ()</code>                  Remove the last element of <code>arr</code> if it exists"},{"location":"pages/reference/functions/arrays/#insert","title":"insert","text":"Overload Description <code>insert&lt;T&gt;(arr: @Array&lt;'T&gt;, elem: 'T, pos: Int) -&gt; ()</code>                  Inserts <code>elem</code> into <code>arr</code> at the position <code>pos</code>"},{"location":"pages/reference/functions/arrays/#remove","title":"remove","text":"Overload Description <code>remove&lt;T&gt;(arr: @Array&lt;'T&gt;, pos: Int) -&gt; ()</code>                  Remove <code>pos</code>'th element of <code>arr</code>"},{"location":"pages/reference/functions/arrays/#set","title":"set","text":"Overload Description <code>set&lt;T&gt;(arr: @Array&lt;'T&gt;, elem: 'T, pos: Int) -&gt; ()</code>                  Sets the <code>pos</code>'th element of <code>arr</code> to <code>elem</code>"},{"location":"pages/reference/functions/ffi/","title":"FFI","text":""},{"location":"pages/reference/functions/ffi/#load_library","title":"load_library","text":"Overload Description <code>load_library(path: String) -&gt; Library</code>                  Read the dynamic library at <code>path</code>"},{"location":"pages/reference/functions/ffi/#get_function","title":"get_function","text":"Overload Description <code>get_function(lib: &amp;Library, function_name: String) -&gt; LibraryFunction</code>                  Gets the <code>function_name</code> function from <code>lib</code>"},{"location":"pages/reference/functions/ffi/#call","title":"call","text":"Overload Description <code>call(func: &amp;LibraryFunction, arg1: *, ...) -&gt; *</code>                  Calls the native function <code>func</code> with the given arguments"},{"location":"pages/reference/functions/io/","title":"I/O","text":""},{"location":"pages/reference/functions/io/#print","title":"print","text":"Overload Description <code>print(obj: Int) -&gt; ()</code>                  Prints <code>obj</code> to stdout              <code>print(obj: Float) -&gt; ()</code> <code>print(obj: Bool) -&gt; ()</code> <code>print(obj: Str) -&gt; ()</code> <code>print(obj: &amp;Int | @Int) -&gt; ()</code> <code>print(obj: &amp;Float | @Float) -&gt; ()</code> <code>print(obj: &amp;Bool | @Bool) -&gt; ()</code> <code>print(obj: &amp;Str | @Str) -&gt; ()</code>"},{"location":"pages/reference/functions/io/#get_file","title":"get_file","text":"Overload Description <code>get_file(path: String) -&gt; File</code>                  Gets handle for the file located at <code>path</code>"},{"location":"pages/reference/functions/io/#open","title":"open","text":"Overload Description <code>open(file: @File, r: Bool, w: Bool, a: Bool) -&gt; ()</code>                  Opens <code>file</code> with permissions to read (<code>r</code>), write (<code>w</code>) and append (<code>a</code>)"},{"location":"pages/reference/functions/io/#close","title":"close","text":"Overload Description <code>close(file: @File) -&gt; ()</code>                  Closes the handle of the file. You can reuse the handle by using the <code>open</code> function"},{"location":"pages/reference/functions/io/#exists","title":"exists","text":"Overload Description <code>exists(file: @File) -&gt; Bool</code>                  returns <code>true</code> if the file exists in the file system"},{"location":"pages/reference/functions/io/#delete","title":"delete","text":"Overload Description <code>delete(file: @File) -&gt; Bool</code>                  Remove <code>file</code> and return <code>true</code> if it succeeded. You can reuse the handle by using the <code>open</code> function"},{"location":"pages/reference/functions/io/#read_str","title":"read_str","text":"Overload Description <code>read_str(file: @File) -&gt; String</code>                  Read the contents of <code>file</code> as a <code>String</code>"},{"location":"pages/reference/functions/io/#read_bytes","title":"read_bytes","text":"Overload Description <code>read_bytes(file: @File) -&gt; Array&lt;Int&gt;</code>                  Read the contents of <code>file</code> as an <code>Array</code> of bytes              <code>read_bytes(file: @File, n: Int) -&gt; Array&lt;Int&gt;</code>                  Read <code>n</code> bytes from <code>file</code>"},{"location":"pages/reference/functions/io/#write_str","title":"write_str","text":"Overload Description <code>write_str(file: @File, str: &amp;String) -&gt; Bool</code>                  Write the contents of <code>str</code> to <code>file</code> and return <code>true</code> if it succeeded"},{"location":"pages/reference/functions/io/#write_bytes","title":"write_bytes","text":"Overload Description <code>write_bytes(file: @File, bytes: &amp;Array&lt;Int&gt;) -&gt; Bool</code>                  Write the contents of <code>bytes</code> to <code>file</code> and return <code>true</code> if it succeeded"},{"location":"pages/reference/functions/io/#input","title":"input","text":"Overload Description <code>input() -&gt; String</code>                  Asks for user input on console and returns it"},{"location":"pages/reference/functions/io/#num_args","title":"num_args","text":"Overload Description <code>num_args() -&gt; Int</code>                  Returns the number of arguments received from stdin"},{"location":"pages/reference/functions/io/#get_arg","title":"get_arg","text":"Overload Description <code>get_arg(i: Int) -&gt; String</code>                  Returns the <code>i</code>'th argument received from stdin"},{"location":"pages/reference/functions/math/","title":"Math","text":""},{"location":"pages/reference/functions/math/#inc","title":"inc","text":"Overload Description <code>inc(n: @Int) -&gt; ()</code>                  Increment <code>n</code> by one"},{"location":"pages/reference/functions/math/#dec","title":"dec","text":"Overload Description <code>dec(n: @Int) -&gt; ()</code>                  Decrement <code>n</code> by one"},{"location":"pages/reference/functions/math/#sin","title":"sin","text":"Overload Description <code>sin(n: Int) -&gt; Float</code>                  Calculates the sine of <code>n</code> <code>sin(n: &amp;Int) -&gt; Float</code> <code>sin(n: @Int) -&gt; Float</code> <code>sin(n: Float) -&gt; Float</code> <code>sin(n: &amp;Float) -&gt; Float</code> <code>sin(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#cos","title":"cos","text":"Overload Description <code>cos(n: Int) -&gt; Float</code>                  Calculates the cosine of <code>n</code> <code>cos(n: &amp;Int) -&gt; Float</code> <code>cos(n: @Int) -&gt; Float</code> <code>cos(n: Float) -&gt; Float</code> <code>cos(n: &amp;Float) -&gt; Float</code> <code>cos(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#tan","title":"tan","text":"Overload Description <code>tan(n: Int) -&gt; Float</code>                  Calculates the tangent of <code>n</code> <code>tan(n: &amp;Int) -&gt; Float</code> <code>tan(n: @Int) -&gt; Float</code> <code>tan(n: Float) -&gt; Float</code> <code>tan(n: &amp;Float) -&gt; Float</code> <code>tan(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#sinh","title":"sinh","text":"Overload Description <code>sinh(n: Int) -&gt; Float</code>                  Calculates the hyperbolic sine of <code>n</code> <code>sinh(n: &amp;Int) -&gt; Float</code> <code>sinh(n: @Int) -&gt; Float</code> <code>sinh(n: Float) -&gt; Float</code> <code>sinh(n: &amp;Float) -&gt; Float</code> <code>sinh(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#cosh","title":"cosh","text":"Overload Description <code>cosh(n: Int) -&gt; Float</code>                  Calculates the hyperbolic cosine of <code>n</code> <code>cosh(n: &amp;Int) -&gt; Float</code> <code>cosh(n: @Int) -&gt; Float</code> <code>cosh(n: Float) -&gt; Float</code> <code>cosh(n: &amp;Float) -&gt; Float</code> <code>cosh(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#tanh","title":"tanh","text":"Overload Description <code>tanh(n: Int) -&gt; Float</code>                  Calculates the hyperbolic tangent of <code>n</code> <code>tanh(n: &amp;Int) -&gt; Float</code> <code>tanh(n: @Int) -&gt; Float</code> <code>tanh(n: Float) -&gt; Float</code> <code>tanh(n: &amp;Float) -&gt; Float</code> <code>tanh(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#ln","title":"ln","text":"Overload Description <code>ln(n: Int) -&gt; Float</code>                  Calculates the natural logarithm of <code>n</code> <code>ln(n: &amp;Int) -&gt; Float</code> <code>ln(n: @Int) -&gt; Float</code> <code>ln(n: Float) -&gt; Float</code> <code>ln(n: &amp;Float) -&gt; Float</code> <code>ln(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#log2","title":"log2","text":"Overload Description <code>log2(n: Int) -&gt; Float</code>                  Calculates the base 2 logarithm of <code>n</code> <code>log2(n: &amp;Int) -&gt; Float</code> <code>log2(n: @Int) -&gt; Float</code> <code>log2(n: Float) -&gt; Float</code> <code>log2(n: &amp;Float) -&gt; Float</code> <code>log2(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#log10","title":"log10","text":"Overload Description <code>log10(n: Int) -&gt; Float</code>                  Calculates the base 10 logarithm of <code>n</code> <code>log10(n: &amp;Int) -&gt; Float</code> <code>log10(n: @Int) -&gt; Float</code> <code>log10(n: Float) -&gt; Float</code> <code>log10(n: &amp;Float) -&gt; Float</code> <code>log10(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#exp","title":"exp","text":"Overload Description <code>exp(n: Int) -&gt; Float</code>                  Calculates the exponential function of <code>n</code> <code>exp(n: &amp;Int) -&gt; Float</code> <code>exp(n: @Int) -&gt; Float</code> <code>exp(n: Float) -&gt; Float</code> <code>exp(n: &amp;Float) -&gt; Float</code> <code>exp(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#sqrt","title":"sqrt","text":"Overload Description <code>sqrt(n: Int) -&gt; Float</code>                  Calculates the square root of <code>n</code> <code>sqrt(n: &amp;Int) -&gt; Float</code> <code>sqrt(n: @Int) -&gt; Float</code> <code>sqrt(n: Float) -&gt; Float</code> <code>sqrt(n: &amp;Float) -&gt; Float</code> <code>sqrt(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#floor","title":"floor","text":"Overload Description <code>floor(n: Float) -&gt; Int</code>                  Calculates <code>n</code> rounded down to the nearest integer              <code>floor(n: &amp;Float) -&gt; Int</code> <code>floor(n: @Float) -&gt; Int</code>"},{"location":"pages/reference/functions/math/#ceil","title":"ceil","text":"Overload Description <code>ceil(n: Float) -&gt; Int</code>                  Calculates <code>n</code> rounded up to the nearest integer              <code>ceil(n: &amp;Float) -&gt; Int</code> <code>ceil(n: @Float) -&gt; Int</code>"},{"location":"pages/reference/functions/math/#fract","title":"fract","text":"Overload Description <code>fract(n: Float) -&gt; Float</code>                  Calculates <code>n</code> rounded up to the nearest integer              <code>fract(n: &amp;Float) -&gt; Float</code> <code>fract(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#abs","title":"abs","text":"Overload Description <code>abs(n: Int) -&gt; Float</code>                  Calculates the absolute value of <code>n</code> <code>abs(n: &amp;Int) -&gt; Float</code> <code>abs(n: @Int) -&gt; Float</code> <code>abs(n: Float) -&gt; Float</code> <code>abs(n: &amp;Float) -&gt; Float</code> <code>abs(n: @Float) -&gt; Float</code>"},{"location":"pages/reference/functions/math/#rand","title":"rand","text":"Overload Description <code>rand() -&gt; Float</code>                  Generates a random number in the range [0, 1]"},{"location":"pages/reference/functions/math/#rand_int","title":"rand_int","text":"Overload Description <p>All reference combinations are defined</p> <code>rand_int(a: Int, b: Int) -&gt; Float</code>                  Generates a random number in the range [<code>a</code>, <code>b</code>]"},{"location":"pages/reference/functions/math/#as_float","title":"as_float","text":"Overload Description <code>as_float(n: Int) -&gt; Float</code>                  Calculates <code>n</code> as a <code>Float</code>. Note that big numbers might not be represented exactly, since                  floating point numbers do not have as much precision              <code>as_float(n: &amp;Int) -&gt; Float</code> <code>as_float(n: @Int) -&gt; Float</code>"},{"location":"pages/reference/functions/memory/","title":"Memory","text":""},{"location":"pages/reference/functions/memory/#is","title":"is","text":"Overload Description <code>is&lt;T&gt;(obj: *) -&gt; Bool</code>                  Returns <code>true</code> if <code>obj</code> is bindable to the type <code>T</code>"},{"location":"pages/reference/functions/memory/#as","title":"as","text":"Overload Description <code>as&lt;T&gt;(obj: *) -&gt; 'T</code>                  Coerces <code>obj</code> to the type <code>T</code>. This does not transform the underlying data,                 only dynamically checks if it is safe to \"trick\" the type system. This is useful when dealing with                 the different variants of sum types."},{"location":"pages/reference/functions/memory/#drop","title":"drop","text":"Overload Description <code>drop&lt;T&gt;(obj: @'T) -&gt; ()</code>                  Deletes the contents to which <code>obj</code> is pointing. You cannot access the data after this                 and every other reference pointing to that data becomes invalid"},{"location":"pages/reference/functions/memory/#move","title":"move","text":"Overload Description <code>move&lt;T&gt;(obj: @'T) -&gt; 'T</code>                  Moves the contents to which <code>obj</code> is pointing to a fresh object of type <code>'T</code>. You cannot access                  the data after this from any reference to the previous location"},{"location":"pages/reference/functions/memory/#swap","title":"swap","text":"Overload Description <code>swap&lt;T&gt;(a: @'T, b: @'T) -&gt; ()</code>                  Interchanges the contents to which <code>a</code> and <code>b</code> are pointing."},{"location":"pages/reference/functions/memory/#ref","title":"ref","text":"Overload Description <code>ref&lt;T&gt;(obj: 'T) -&gt; &amp;'T</code>                  Creates a reference to <code>obj</code>"},{"location":"pages/reference/functions/memory/#mut","title":"mut","text":"Overload Description <code>mut&lt;T&gt;(obj: 'T) -&gt; @'T</code>                  Creates a mutable reference to <code>obj</code>"},{"location":"pages/reference/functions/memory/#deref","title":"deref","text":"Overload Description <code>mut&lt;T&gt;(obj: &amp;'T) -&gt; 'T</code>                  Copies the contents to which <code>obj</code> is pointing              <code>mut&lt;T&gt;(obj: @'T) -&gt; 'T</code>"},{"location":"pages/reference/functions/memory/#demut","title":"demut","text":"Overload Description <code>mut&lt;T&gt;(obj: @'T) -&gt; &amp;'T</code>                  Creates a reference to <code>obj</code> from a mutable reference"},{"location":"pages/reference/functions/memory/#fwd","title":"fwd","text":"Overload Description <code>fwd&lt;T&gt;(obj: *) -&gt; 'T</code>                  Takes <code>obj</code> and tries to convert it to the type <code>T</code>:                   <ul> <li>If the data's type and <code>T</code> are the same, then the object is returned as is</li> <li>If the object is a mutable reference and <code>T</code> is a value, the function will do the same as <code>move</code></li> <li>If the object is a reference and <code>T</code> is a value, the function will do the same as <code>deref</code></li> <li>If <code>obj</code> is a reference and <code>T</code> is a mutable reference, the function will do the same as <code>demut</code></li> </ul>                 This function is useful when creating generic code for getting around references."},{"location":"pages/reference/functions/memory/#cfwd","title":"cfwd","text":"Overload Description <code>cfwd&lt;T&gt;(obj: *) -&gt; 'T</code>                  The same as <code>fwd</code>, but clones objects instead of moving them"},{"location":"pages/reference/functions/memory/#write_ptr_int","title":"write_ptr_int","text":"Overload Description <code>write_ptr_int(ptr: Pointer, offset: Int, value: Int)</code>                  Writes an int (64 bits) to <code>ptr</code> with offset <code>value</code> (1 is 64 bits). Take into account that this function is unsafe                 and assumes that you allocated the memory using a native function"},{"location":"pages/reference/functions/memory/#write_ptr_float","title":"write_ptr_float","text":"Overload Description <code>write_ptr_float(ptr: Pointer, offset: Int, value: Float)</code>                  Writes a double (64 bits) to <code>ptr</code> with offset <code>value</code> (1 is 64 bits). Take into account that this function is unsafe                 and assumes that you allocated the memory using a native function"},{"location":"pages/reference/functions/misc/","title":"Miscellaneous","text":""},{"location":"pages/reference/functions/misc/#time","title":"time","text":"Overload Description <code>time() -&gt; Int</code>                  Returns the current time (starting from the UNIX epoch) in nanoseconds"},{"location":"pages/reference/functions/misc/#truncate","title":"truncate","text":"Overload Description <code>truncate(n: Int) -&gt; Int</code>                  Truncates <code>n</code> to be 64 bits at most, keeping the least significat bits"},{"location":"pages/reference/functions/misc/#panic","title":"panic","text":"Overload Description <code>panic(err: String) -&gt; ()</code>                  Throws <code>err</code> as an error and stops the execution of the program"},{"location":"pages/reference/functions/misc/#emit","title":"emit","text":"<p>Only available in macro code execution contexts</p> Overload Description <code>emit(text: String) -&gt; ()</code>                  Sends <code>text</code> to the macro output buffer to parse the whole buffer when the execution context ends"},{"location":"pages/reference/functions/strings/","title":"Strings","text":""},{"location":"pages/reference/functions/strings/#to_string","title":"to_string","text":"Overload Description <code>to_string(n: Int) -&gt; String</code>                  Returns <code>n</code> as a <code>String</code>"},{"location":"pages/reference/functions/strings/#code_point_at","title":"code_point_at","text":"Overload Description <code>code_point_at(str: &amp;String, n: Int) -&gt; Int</code>                  Returns the unicode code point in <code>str</code> at the position <code>n</code> <code>code_point_at(str: @String, n: Int) -&gt; Int</code>"},{"location":"pages/reference/functions/strings/#code_point_to_str","title":"code_point_to_str","text":"Overload Description <code>code_point_to_str(n: Int) -&gt; String</code>                  Returns <code>n</code> as a <code>String</code>, using it as an unicode code point"},{"location":"pages/reference/functions/strings/#code_point_length","title":"code_point_length","text":"Overload Description <code>code_point_length(n: Int) -&gt; Int</code>                  Returns the length in bytes of <code>n</code> when encoded in UTF-8"},{"location":"pages/reference/functions/strings/#utf8_array","title":"utf8_array","text":"Overload Description <code>utf8_array(str: &amp;String) -&gt; Array&lt;Int&gt;</code>                  Returns <code>str</code> encoded in UTF-8              <code>utf8_array(str: @String) -&gt; Array&lt;Int&gt;</code>"},{"location":"pages/reference/functions/strings/#utf8_to_str","title":"utf8_to_str","text":"Overload Description <code>utf8_to_str(arr: &amp;Array&lt;Int&gt;) -&gt; String</code>                  Returns <code>arr</code> as a <code>String</code>, assuming it is encoded in UTF-8              <code>utf8_to_str(arr: @Array&lt;Int&gt;) -&gt; String</code>"},{"location":"pages/reference/interfaces/destroyable/","title":"Destroyable","text":"<p>These are the functions that are needed to implement the interface <code>Destroyable</code>:</p>"},{"location":"pages/reference/interfaces/destroyable/#destroy","title":"destroy","text":"Overload Description <code>destroy(obj: &amp;Self) -&gt; ()</code>                  Frees the memory of <code>obj</code>"},{"location":"pages/reference/interfaces/iterable/","title":"Iterable","text":"<p>These are the functions that are needed to implement the interface <code>Iterable&lt;'Iterator, 'Element&gt;</code>:</p>"},{"location":"pages/reference/interfaces/iterable/#iterator","title":"iterator","text":"Overload Description <code>iterator(obj: Self) -&gt; 'Iterator</code>                  Creates an iterator of type <code>'Iterator</code> over <code>obj</code>"},{"location":"pages/reference/interfaces/iterable/#next","title":"next","text":"Overload Description <code>next(it: @'Iterator) -&gt; 'Element</code>                  Returns the next element in the iterator and advances it"},{"location":"pages/reference/interfaces/iterable/#is_consumed","title":"is_consumed","text":"Overload Description <code>is_consumed(it: @'Iterator) -&gt; Bool</code>                  Returns <code>true</code> if the iterator has no more elements to traverse"},{"location":"pages/reference/interfaces/printable/","title":"Printable","text":"<p>These are the functions that are needed to implement the interface <code>Printable</code>:</p>"},{"location":"pages/reference/interfaces/printable/#print","title":"print","text":"Overload Description <code>print(obj: Self) -&gt; ()</code>                  Prints <code>obj</code> to stdout"},{"location":"pages/reference/operators/arrays/","title":"Arrays","text":""},{"location":"pages/reference/operators/arrays/#n-ary","title":"N-ary","text":""},{"location":"pages/reference/operators/arrays/#precedence-75","title":"[ ] [ Precedence 75 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>&lt;T&gt; (arr: Array&lt;'T&gt;)[idx: Int] -&gt; 'T</code>                  Returns the <code>idx</code>'th element of <code>arr</code>"},{"location":"pages/reference/operators/bitwise/","title":"Bitwise","text":""},{"location":"pages/reference/operators/bitwise/#prefix","title":"Prefix","text":""},{"location":"pages/reference/operators/bitwise/#precedence-250","title":"! [ Precedence 250 ]","text":"Overload Description <code>! (n: Int) -&gt; Int</code>                  Negates the bits of <code>n</code> <code>! (n &amp;Int) -&gt; Int</code> <code>! (n @Int) -&gt; Int</code>"},{"location":"pages/reference/operators/bitwise/#binary","title":"Binary","text":""},{"location":"pages/reference/operators/bitwise/#precedence-370","title":"&amp; [ Precedence 370 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) &amp; (b: Int) -&gt; Int</code>                  Calculates the bitwise operation <code>a</code> \u2227 <code>b</code>"},{"location":"pages/reference/operators/bitwise/#precedence-380","title":"| [ Precedence 380 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) | (b: Int) -&gt; Int</code>                  Calculates the bitwise operation <code>a</code> \u2228 <code>b</code>"},{"location":"pages/reference/operators/bitwise/#precedence-350","title":"&gt;&gt; [ Precedence 350 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) &gt;&gt; (b: Int) -&gt; Int</code>                  Calculates <code>a</code> with <code>b</code> bits shifted to the right"},{"location":"pages/reference/operators/bitwise/#precedence-360","title":"&lt;&lt; [ Precedence 360 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) &lt;&lt; (b: Int) -&gt; Int</code>                  Calculates <code>a</code> with <code>b</code> bits shifted to the left"},{"location":"pages/reference/operators/bitwise/#precedence-390","title":"^ [ Precedence 390 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) ^ (b: Int) -&gt; Int</code>                  Calculates the bitwise operation <code>a</code> XOR <code>b</code>"},{"location":"pages/reference/operators/internal/","title":"Internal","text":""},{"location":"pages/reference/operators/internal/#binary","title":"Binary","text":""},{"location":"pages/reference/operators/internal/#precedence-100000","title":":= [ Precedence 100000 ]","text":"Overload Description <code>&lt;T&gt; (a: @'T) := (b: 'T) -&gt; ()</code>                  Assigns <code>b</code> to the value to which <code>b</code> is pointing"},{"location":"pages/reference/operators/internal/#n-ary","title":"N-ary","text":""},{"location":"pages/reference/operators/internal/#precedence-50","title":"( ) [ Precedence 50 ]","text":"Overload Description <code>&lt;R&gt; (f: () =&gt; 'R)() -&gt; R</code>                  Calls <code>f</code> with the provided arguments              <code>&lt;A1, R&gt; (f: 'A1 =&gt; 'R)(a1: 'A1) -&gt; R</code> <code>&lt;A1, A2, R&gt; (f: ('A1, 'A2) =&gt; 'R)(a1: 'A1, a2: 'A2) -&gt; R</code> <p>Defined until length 30</p>"},{"location":"pages/reference/operators/logical/","title":"Logical","text":""},{"location":"pages/reference/operators/logical/#prefix","title":"Prefix","text":""},{"location":"pages/reference/operators/logical/#precedence-250","title":"! [ Precedence 250 ]","text":"Overload Description <code>! (v: Bool) -&gt; Bool</code>                  Negates <code>v</code> <code>! (v: &amp;Bool) -&gt; Bool</code> <code>! (v: @Bool) -&gt; Bool</code>"},{"location":"pages/reference/operators/logical/#binary","title":"Binary","text":""},{"location":"pages/reference/operators/logical/#precedence-1500","title":"&amp;&amp; [ Precedence 1500 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Bool) &amp;&amp; (b: Bool) -&gt; Bool</code>                  Calculates the logical operation <code>a</code> \u2227 <code>b</code>. It short-circuits"},{"location":"pages/reference/operators/logical/#precedence-1550","title":"|| [ Precedence 1550 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Bool) || (b: Bool) -&gt; Bool</code>                  Calculates the logical operation <code>a</code> \u2228 <code>b</code>. It short-circuits"},{"location":"pages/reference/operators/logical/#precedence-390","title":"^ [ Precedence 390 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Bool) ^ (b: Bool) -&gt; Bool</code>                  Calculates the logical operation <code>a</code> XOR <code>b</code>"},{"location":"pages/reference/operators/logical/#precedence-900","title":"&lt; [ Precedence 900 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) &lt; (b: Int) -&gt; Bool</code>                  Calculates whether or not <code>a</code> is lower than <code>b</code> <p>All reference combinations are defined</p> <code>(a: Float) &lt; (b: Float) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: Int) &lt; (b: Float) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: Float) &lt; (b: Int) -&gt; Bool</code>"},{"location":"pages/reference/operators/logical/#precedence-1000","title":"&lt;= [ Precedence 1000 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) &lt;= (b: Int) -&gt; Bool</code>                  Calculates whether or not <code>a</code> is lower or equal to <code>b</code> <p>All reference combinations are defined</p> <code>(a: Float) &lt;= (b: Float) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: Int) &lt;= (b: Float) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: Float) &lt;= (b: Int) -&gt; Bool</code>"},{"location":"pages/reference/operators/logical/#precedence-950","title":"&gt; [ Precedence 950 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) &gt; (b: Int) -&gt; Bool</code>                  Calculates whether or not <code>a</code> is greater than <code>b</code> <p>All reference combinations are defined</p> <code>(a: Float) &gt; (b: Float) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: Int) &gt; (b: Float) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: Float) &gt; (b: Int) -&gt; Bool</code>"},{"location":"pages/reference/operators/logical/#precedence-1050","title":"&gt;= [ Precedence 1050 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) &gt;= (b: Int) -&gt; Bool</code>                  Calculates whether or not <code>a</code> is greater or equal to <code>b</code> <p>All reference combinations are defined</p> <code>(a: Float) &gt;= (b: Float) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: Int) &gt;= (b: Float) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: Float) &gt;= (b: Int) -&gt; Bool</code>"},{"location":"pages/reference/operators/logical/#precedence-1100","title":"== [ Precedence 1100 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) == (b: Int) -&gt; Bool</code>                  Calculates whether or not <code>a</code> is equal to <code>b</code> <p>All reference combinations are defined</p> <code>(a: Float) == (b: Float) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: Bool) == (b: Bool) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: String) == (b: String) -&gt; Bool</code>"},{"location":"pages/reference/operators/logical/#precedence-1150","title":"!= [ Precedence 1150 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) != (b: Int) -&gt; Bool</code>                  Calculates whether or not <code>a</code> is different to <code>b</code> <p>All reference combinations are defined</p> <code>(a: Float) != (b: Float) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: Int) != (b: Float) -&gt; Bool</code> <p>All reference combinations are defined</p> <code>(a: Float) != (b: Int) -&gt; Bool</code>"},{"location":"pages/reference/operators/math/","title":"Math","text":""},{"location":"pages/reference/operators/math/#prefix","title":"Prefix","text":""},{"location":"pages/reference/operators/math/#-precedence-300","title":"- [ Precedence 300 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>- (n: Int) -&gt; Int</code>                  Negates <code>n</code> <p>All reference combinations are defined</p> <code>- (n: Float) -&gt; Float</code>"},{"location":"pages/reference/operators/math/#binary","title":"Binary","text":""},{"location":"pages/reference/operators/math/#precedence-650","title":"+ [ Precedence 650 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) + (b: Int) -&gt; Int</code>                  Calculates the sum of <code>a</code> and <code>b</code> <p>All reference combinations are defined</p> <code>(a: Float) + (b: Float) -&gt; Float</code> <p>All reference combinations are defined</p> <code>(a: Int) + (b: Float) -&gt; Float</code> <p>All reference combinations are defined</p> <code>(a: Float) + (b: Int) -&gt; Float</code> <p>All reference combinations are defined</p> <code>(a: String) + (b: String) -&gt; String</code>                  Concatenates <code>a</code> and <code>b</code>"},{"location":"pages/reference/operators/math/#-precedence-700","title":"- [ Precedence 700 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) - (b: Int) -&gt; Int</code>                  Calculates the difference between <code>a</code> and <code>b</code> <p>All reference combinations are defined</p> <code>(a: Float) - (b: Float) -&gt; Float</code> <p>All reference combinations are defined</p> <code>(a: Int) - (b: Float) -&gt; Float</code> <p>All reference combinations are defined</p> <code>(a: Float) - (b: Int) -&gt; Float</code>"},{"location":"pages/reference/operators/math/#precedence-500","title":"* [ Precedence 500 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) * (b: Int) -&gt; Int</code>                  Calculates the product of <code>a</code> and <code>b</code> <p>All reference combinations are defined</p> <code>(a: Float) * (b: Float) -&gt; Float</code> <p>All reference combinations are defined</p> <code>(a: Int) * (b: Float) -&gt; Float</code> <p>All reference combinations are defined</p> <code>(a: Float) * (b: Int) -&gt; Float</code>"},{"location":"pages/reference/operators/math/#precedence-550","title":"/ [ Precedence 550 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) / (b: Int) -&gt; Int</code>                  Calculates the quotient between <code>a</code> and <code>b</code> <p>All reference combinations are defined</p> <code>(a: Float) / (b: Float) -&gt; Float</code> <p>All reference combinations are defined</p> <code>(a: Int) / (b: Float) -&gt; Float</code> <p>All reference combinations are defined</p> <code>(a: Float) / (b: Int) -&gt; Float</code>"},{"location":"pages/reference/operators/math/#precedence-600","title":"% [ Precedence 600 ]","text":"Overload Description <p>All reference combinations are defined</p> <code>(a: Int) % (b: Int) -&gt; Int</code>                  Calculates the remainder of the division between <code>a</code> and <code>b</code> <p>All reference combinations are defined</p> <code>(a: Float) % (b: Float) -&gt; Float</code> <p>All reference combinations are defined</p> <code>(a: Int) % (b: Float) -&gt; Float</code> <p>All reference combinations are defined</p> <code>(a: Float) % (b: Int) -&gt; Float</code>"},{"location":"pages/tutorial/examples/comprehension/","title":"List Comprehension Syntax","text":"<p>Let's create arguably one of the most useful constructs when working with iterable structures: list comprehensions. This can be done thanks to Ryna's syntax definition features.</p>"},{"location":"pages/tutorial/examples/comprehension/#what-is-list-comprehension","title":"What is list comprehension?","text":"<p>List comprehensions are a syntax option in some languages that allow the programmer to transform the values of a list or even filter them without having to create an explicit for loop and a temporary variable. In this case, we will not deal with filtering the list.</p>"},{"location":"pages/tutorial/examples/comprehension/#creating-the-syntax","title":"Creating the syntax","text":"<p>The syntax for list comprehensions then to be something like this:</p> <pre><code>[expr for elem in container]\n</code></pre> <p>This is problematic for us because Ryna is a strongly typed language. We will have to adapt it like this:</p> <pre><code>[expr for elem: ElemType in container]\n</code></pre> <p>This can be expressed in NDL like this:</p> <pre><code>\"[\" \n    [s] Arg(&lt;expr&gt;, map) [s]                                        // Map expression\n    \"for\" [s] Arg(&lt;ident&gt;, it) [s] \":\" [s] Arg(&lt;type&gt;, type) [s]    // Element\n    \"in\" [s] Arg(&lt;expr&gt;, container) [s]                             // Container\n\"]\"\n</code></pre> <p>Note that you need <code>Arg</code>s to mark the variables that we will use inside the body.</p>"},{"location":"pages/tutorial/examples/comprehension/#generating-the-body","title":"Generating the body","text":"<p>Internally, a list comprehension is just a for loop with a transformation function. There are multiple ways to do this, but this is one of them (again, note that we have to escape the for's closing brace):</p> <pre><code>syntax list_comprehension from [...] {\n    let res = arr&lt;$type&gt;();\n    let func = ($it: $type) -&gt; $type $map;\n\n    for _it_ in $container {\n        res.push(func(*_it_));\n    \\}\n\n    return move(res);\n}\n</code></pre>"},{"location":"pages/tutorial/examples/comprehension/#example","title":"Example","text":"<p>Making use of an <code>Array</code> initialization syntax, you can build the following code:</p> <pre><code>let array = [i * 2 for i: Int in &lt;Int&gt;[1, 2, 3, 4, 5]]; // [2, 4, 6, 8, 10]\n</code></pre> <p>This would compile to:</p> <pre><code>let array = do {\n    let res = arr&lt;Int&gt;();\n    let func = (i: Int) -&gt; Int i * 2;\n\n    for _it_ in &lt;Int&gt;[1, 2, 3, 4, 5] {\n        res.push(func(*_it_));\n    }\n\n    return *res;\n};\n</code></pre> <p>In this example <code>&lt;Int&gt;[1, 2, 3, 4, 5]</code> would also be recursively compiled into a new expression based on a lambda expression, but the exact compilation is not important.</p>"},{"location":"pages/tutorial/examples/embedding/","title":"Embedding a Language","text":"<p>Ryna's powerful macro system allows you to execute arbitrary code inside a macro in order to create new functionalities. In this page you will learn how to embed a simple esoteric language into Ryna, but be aware that this concept can be turned into something more interesting very easily.</p>"},{"location":"pages/tutorial/examples/embedding/#about-the-language","title":"About the language","text":"<p>The language that we are going to embed is a very simple one called Brainfuck. The exact implementation details are not that important in this tutorial, but we have to know some things about it:</p> <ol> <li>Its memory model is an infinite tape (T) of integers. We will approximate it with a large <code>Array&lt;Int&gt;</code>.</li> <li>It has a memory pointer (P) that moves on the tape and changes the values there. This will be an <code>Int</code>.</li> <li>Each of its instructions take a single character: <code>+</code>, <code>-</code>, <code>&lt;</code>, <code>&gt;</code>, <code>[</code>, <code>]</code>, <code>.</code> and <code>,</code>. A program consists of    many of these in sequence.</li> <li>Any character not present on the list before must be ignored.</li> </ol> <p>Finally, the instructions do the following when executed:</p> Instruction Effect &gt; Increase P by one &lt; Decrease P by one + Increase T[P] by one - Decrease T[P] by one [ Jump to the matching <code>]</code> if T[P] is 0 ] Jump to the matching <code>[</code> if T[P] is not 0 . Output T[P] , Input value to T[P]"},{"location":"pages/tutorial/examples/embedding/#matching-the-language","title":"Matching the language","text":"<p>Since the language is so simple, the NDL pattern that matches a program is the following:</p> <pre><code>1{\"+\" | \"-\" | \"&lt;\" | \"&gt;\" | \"[\" | \"]\" | \".\" | \",\"}\n</code></pre> <p>In this case, we will let the <code>,</code> operation as an exercise to the reader, but output will be programmed.</p> <p>In order to be able to delimit the language effectively, we will use braces and a new keyword <code>BF</code>. The complete syntax for a Brainfuck blockm will be the following:</p> <pre><code>BF {\n    /* code goes here */\n}\n</code></pre> <p>For this, we have to use the following NDL pattern:</p> <pre><code>\"BF\" [s] \"{\" Arg(1{s | \"+\" | \"-\" | \".\" | \"&lt;\" | \"&gt;\" | \"[\" | \"]\"}, code) \"}\"\n</code></pre>"},{"location":"pages/tutorial/examples/embedding/#creating-the-macro","title":"Creating the macro","text":"<p>In order to write smaller code, we will use some helper functions to create the memory array:</p> <pre><code>fn&lt;T&gt; arr_with_capacity(size: Int) -&gt; Array&lt;'T&gt; {\n    let res = arr&lt;'T&gt;();\n    res.reserve(move(size));\n\n    return move(res);\n}\n\nfn&lt;T&gt; fill(array: @Array&lt;'T&gt;, value: 'T) -&gt; @Array&lt;'T&gt; {\n    while array.capacity() &gt; array.len() {\n        array.push(*value);\n    }\n\n    return array;\n}\n</code></pre> <p>With this, we can initialize the memory array like this:</p> <pre><code>let mem = arr_with_capacity&lt;Int&gt;(1000);\nmem.fill(0);\n</code></pre> <p>Given this, we can begin our macro code pattern like this:</p> <pre><code>syntax block embed_bf from \"BF\" [s] \"{\" Arg(1{s | \"+\" | \"-\" | \".\" | \"&lt;\" | \"&gt;\" | \"[\" | \"]\"}, code) \"}\" {\n    {|        \n        // Memory array\n        emit(\"let mem = arr_with_capacity&lt;Int&gt;(1000);\");\n        emit(\"mem.fill(0);\");\n    |}\n}\n</code></pre> <p>Later, we must create the memory pointer in a similar way:</p> <pre><code>{|        \n    // ...\n\n    // Pointer\n    // This value is arbitrary, but more or less in the middle to allow some movement\n    emit(\"let pt = 500;\");\n\n    // ...\n|}\n</code></pre> <p>With this, we can begin generating the code that corresponds to the embedded Brainfuck code. For this, we have to create a variable inside the macro code pattern by using a variable pattern and iterate over each character:</p> <pre><code>{|        \n    // ...\n\n    // Code\n    let code = \"$code\".ref().utf8_array();\n\n    // Execution\n    for i in code {\n        // Handle each case\n    \\}\n\n    // ...\n|}\n</code></pre> <p>Now comes the hardest part: translating the instructions to valid Ryna code given our simple model. For this, we will translate the <code>&gt;</code> and <code>&lt;</code> operations as changing <code>pt</code>, <code>+</code> and <code>-</code> as changing the value in <code>mem[*pt]</code> and <code>.</code> as writing to an array outside the macro. Interestingly, <code>[</code> and <code>]</code> can be handled by being translated to <code>while mem[*pt] != 0 {</code> and <code>}</code>, respectively. We have to be careful because every closing brace must be escaped if it is not the one that closes the code pattern (including the ones inside strings).</p> <p>The final code that handles the instructions is the following:</p> <pre><code>{|        \n    // ...\n\n    // Execution\n    for i in code {\n        if i == '+' { \n            emit(\"mem[*pt] := mem[*pt] + 1;\"); // +\n\n        \\} else if i == '-' {\n            emit(\"mem[*pt] := mem[*pt] - 1;\"); // -\n\n        \\} else if i == '.' {\n            emit(\"out.push(*mem[*pt]);\");      // .\n\n        \\} else if i == '&lt;' {\n            emit(\"pt = pt - 1;\");              // &lt;\n\n        \\} else if i == '&gt;' {\n            emit(\"pt = pt + 1;\");              // &gt;\n\n        \\} else if i == '[' {\n            emit(\"while mem[*pt] != 0 {\");     // [\n\n        \\} else if i == ']' {\n            emit(\"\\}\");                        // ]\n        \\}\n    \\}\n\n    // ...\n|}\n</code></pre> <p>After all this, we would have a functional macro that lets us embed Brainfuck code into Ryna! This would be the complete code  and an example:</p> <pre><code>// Helper functions\nfn&lt;T&gt; arr_with_capacity(size: Int) -&gt; Array&lt;'T&gt; {\n    let res = arr&lt;'T&gt;();\n    res.reserve(move(size));\n\n    return move(res);\n}\n\nfn&lt;T&gt; fill(array: @Array&lt;'T&gt;, value: 'T) -&gt; @Array&lt;'T&gt; {\n    while array.capacity() &gt; array.len() {\n        array.push(*value);\n    }\n\n    return array;\n}\n\n// Input is not allowed in this example\nsyntax block embed_bf from \"BF\" [s] \"{\" Arg(1{s | \"+\" | \"-\" | \".\" | \"&lt;\" | \"&gt;\" | \"[\" | \"]\"}, code) \"}\" {\n    {|        \n        // Memory array\n        emit(\"let mem = arr_with_capacity&lt;Int&gt;(1000);\");\n        emit(\"mem.fill(0);\");\n\n        // Pointer\n        emit(\"let pt = 500;\");\n\n        // Code\n        let code = \"$code\".ref().utf8_array();\n\n        // Execution\n        for i in code {\n            if i == '+' { \n                emit(\"mem[*pt] := mem[*pt] + 1;\"); // +\n\n            \\} else if i == '-' {\n                emit(\"mem[*pt] := mem[*pt] - 1;\"); // -\n\n            \\} else if i == '.' {\n                emit(\"out.push(*mem[*pt]);\");      // .\n\n            \\} else if i == '&lt;' {\n                emit(\"pt = pt - 1;\");              // &lt;\n\n            \\} else if i == '&gt;' {\n                emit(\"pt = pt + 1;\");              // &gt;\n\n            \\} else if i == '[' {\n                emit(\"while mem[*pt] != 0 {\");     // [\n\n            \\} else if i == ']' {\n                emit(\"\\}\");                        // ]\n            \\}\n        \\}\n    |}\n}\n\nlet out = arr&lt;Int&gt;();\n\n// Taken from https://en.wikipedia.org/wiki/Brainfuck\nBF {\n    ++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++.\n}\n\nprint(utf8_to_str(out.demut())); // Prints \"Hello World!\\n\"\n</code></pre> <p>As we said before, this example does not include input, but it could be trivially added by using an array defined outside the macro. Also, some parts could have been done by using other macro generator patterns, but it is a good exercise to  illustrate the power of compile time code execution.</p>"},{"location":"pages/tutorial/examples/linked%20list/","title":"Linked List using ADTs","text":"<p>Let's see how we can make use of Ryna's features to program a Linked List. This will guide you through all the design process and all the common pitfalls that you might face.</p>"},{"location":"pages/tutorial/examples/linked%20list/#what-is-a-linked-list","title":"What is a Linked List?","text":"<p>A Linked List is a common data structure that is used to store several elements in sequence. It's not the same as an array, since those store elements sequentially in memory and Linked Lists do not. This makes these structures useful for very big, constantly growing data.</p> <p>A Linked List consists of a series of nodes with references to the next node in the sequence. Every node has an element of the list except for theh last one, that is called sentinel and just marks the end of the list:</p> <pre><code>%% mermaid\ngraph LR\n    1 --&gt; 2\n    2 --&gt; 3\n    3 --&gt; ...\n    ... --&gt; End\n</code></pre>"},{"location":"pages/tutorial/examples/linked%20list/#a-first-approach","title":"A first approach","text":"<p>These are probably the most common recursive data structure to implement when learning about algebraic data types. The basic idea is to first  create an empty class for the sentinel (usually called <code>Nil</code>):</p> <pre><code>class Nil {}\n</code></pre> <p>After this, you can represent a Linked List (of <code>Int</code>s, for example) like this:</p> <pre><code>type List = Nil | (Int, List);\n</code></pre> <p>This means that a Linked List is either an empty <code>List</code> (<code>Nil</code>) or a value followed by another <code>List</code>. This recursion is enough to make it store any amount of data:</p> <pre><code>let a: List = Nil();            // Empty list\nlet b: List = (1, Nil());       // List of one element\nlet c: List = (2, (1, Nil()));  // List of two elements\n[...]\n</code></pre> <p>After this, you can build some utility functions:</p> <pre><code>// Add a new element\nfn add(list: List, number: Int) -&gt; List {\n    return (*number, *list);\n}\n\n// Get every element but the first\nfn rest(list: @List) -&gt; @List {\n    return list.as&lt;@(Int, List)&gt;().get_1();\n}\n\n// Get size of the list\nfn size(list: @List) -&gt; Int {\n    if list.is&lt;@Nil&gt;() { // The size of an empty list is 0\n        return 0;\n    }\n\n    return 1 + list.rest().size(); // Else the size is 1 + the size of the rest\n}\n</code></pre> <p>Note that these functions are not crafted to avoid unnecessary copies, so they might be made more efficient.</p>"},{"location":"pages/tutorial/examples/linked%20list/#going-generic","title":"Going generic","text":"<p>Now you might want to make the structure generic, this is actually not very difficult given what we have:</p> <pre><code>type List&lt;T&gt; = Nil | ('T, List&lt;'T&gt;);\n</code></pre> <p>Now this code is legal:</p> <pre><code>let a: List&lt;Int&gt; = Nil();                  // Empty list\nlet b: List&lt;Bool&gt; = (true, Nil());         // List of one element\nlet c: List&lt;Float&gt; = (2.2, (1.1, Nil()));  // List of two elements\n[...]\n</code></pre> <p>Adapting the rest of the functions is left as an exercise to the reader :)</p>"},{"location":"pages/tutorial/examples/serialization/","title":"Serialization Interface","text":"<p>Now we are goint to write an interface for serializing generic data to different formats. This is not the only way, but gives a strong base to begin with.</p>"},{"location":"pages/tutorial/examples/serialization/#serializable-interface","title":"Serializable interface","text":"<p>The main things you would want to support are the following:</p> <ol> <li>Serialize any kind of data.</li> <li>Support multiple output formats.</li> <li>Do not make any unnecessary work.</li> </ol> <p>One way to do this is to define a <code>Serializable</code> interface and a class for each format you want to support:</p> <pre><code>interface Serializable&lt;Serializer&gt; {\n    fn serialize(serializer: @'Serializer, obj: Self) -&gt; String;\n}\n\n// A class for each format. These might have state\nclass SerializerFormat1 {}\nclass SerializerFormat2 {}\nclass SerializerFormat3 {}\n[...]\n</code></pre> <p>After this, you could implement <code>Serializable&lt;FormatClass&gt;</code> for each datat type that you want to be able to serialize:</p> <pre><code>fn serialize(serializer: @SerializerFormat1, obj: Int) -&gt; String {\n    [...]\n}\n\nimplement Serializable&lt;SerializerFormat1&gt; for Int;\n</code></pre>"},{"location":"pages/tutorial/examples/serialization/#json","title":"JSON","text":"<p>Let's build an example for JSON using a class called <code>JSONSerializer</code>:</p> <pre><code>// Serializer class\nclass JSONSerializer {}\n\n// Functions\nfn serialize(serializer: @JSONSerializer, obj: Int) -&gt; String {\n    return obj.deref().to_string();\n}\n\nfn serialize(serializer: @JSONSerializer, obj: Float) -&gt; String {\n    return obj.deref().to_string();\n}\n\nfn serialize(serializer: @JSONSerializer, obj: String) -&gt; String {\n    return \"\\\"\" + obj + \"\\\"\";\n}\n\n// Implementations\nimplement Serializable&lt;JSONSerializer&gt; for Int;\nimplement Serializable&lt;JSONSerializer&gt; for Float;\nimplement Serializable&lt;JSONSerializer&gt; for String;\n</code></pre> <p>Now you can make use of what you built to create <code>Array</code> serialization:</p> <pre><code>import * from range;\n\nfn&lt;T&gt; serialize(serializer: @JSONSerializer, obj: Array&lt;'T [Serializable&lt;JSONSerializer&gt;]&gt;) -&gt; String {\n    let res = \"[\";\n\n    for i in range(0, obj.len()) {\n        res = res + serializer.serialize(*obj[i]);\n\n        if i &lt; obj.len() - 1 {\n            res = res + \", \";\n        }\n    }\n\n    return res + \"]\";\n}\n\nimplement&lt;T&gt; Serializable&lt;JSONSerializer&gt; for Array&lt;'T [Serializable&lt;JSONSerializer&gt;]&gt;;\n</code></pre> <p>This code allows you to use bounded template substitution to specify that an <code>Array</code> of <code>'T</code> is serializable as long as <code>'T</code> is also serializable. Note that We import the range standard library, this is not strictly needed.</p> <p>Now we only have dictionaries left. This is one way to support them by using custom classes:</p> <pre><code>// Class to serialize\nclass Test {\n    att_a: Int;\n    att_b: Array&lt;Float&gt;;\n}\n\n// Fucntions\nfn&lt;K, V&gt; serialize_map_field(serializer: @JSONSerializer, key: 'K [Serializable&lt;JSONSerializer&gt;], value: 'V [Serializable&lt;JSONSerializer&gt;]) -&gt; String {\n    return serializer.serialize(*key) + \": \" + serializer.serialize(*value);\n}\n\nfn serialize(serializer: @JSONSerializer, obj: Test) -&gt; String {\n    let a = serializer.serialize_map_field(\"att_a\", move(obj.att_a));\n    let b = serializer.serialize_map_field(\"att_b\", move(obj.att_b));\n\n    return \"{\" + a + \", \" + b + \"}\";\n}\n\n// Implementation\nimplement Serializable&lt;JSONSerializer&gt; for Test;\n</code></pre> <p>After this you can serialize <code>Test</code> instances like this: </p> <pre><code>let serializer = JSONSerializer();\nlet a = arr&lt;Float&gt;();\na.push(5.2);\na.push(8.76);\na.push(15.9);\n\nlet test = Test(10, move(a));\n\nprint(serializer.serialize(move(test))); // Prints {\"att_a\": 10, \"att_b\": [5.2, 8.76, 15.9]}\n</code></pre>"},{"location":"pages/tutorial/examples/ternary/","title":"Building a Ternary Operator","text":"<p>A common construct in programming languages is the ternary operator. Contrary to what the name implies, it cannot be implemented easily in Ryna with operators, since they are eager and the ternary operator is lazy. Let's take a look at how to implement it.</p>"},{"location":"pages/tutorial/examples/ternary/#syntax","title":"Syntax","text":"<p>The common syntax for the ternary operator is the following:</p> <pre><code>condition ? if_true : if_false\n</code></pre> <p>This syntax poses a problem, and it is that it makes the parser run out of memory. This is something that you might have to fight sometimes. This can easily be fixed by using delimiters:</p> <pre><code>{ condition ? if_true : if_false }\n</code></pre> <p>We can represent this syntax using the following NDL pattern:</p> <pre><code>\"{\" \n    {s} Arg(&lt;expr&gt;, condition) {s} \"?\" \n    {s} Arg(&lt;expr&gt;, if_true) {s} \":\" \n    {s} Arg(&lt;expr&gt;, if_false) {s} \n\"}\"\n</code></pre>"},{"location":"pages/tutorial/examples/ternary/#creating-the-macro","title":"Creating the macro","text":"<p>You can create the macro for the ternary operator using the following code (note that we have to escape the if's closing brace):</p> <pre><code>syntax ternary_operator from [...] {\n    if $condition {\n        return $if_true;\n    \\}\n\n    return $if_false;\n}\n</code></pre> <p>After this, you can write code such as this one:</p> <pre><code>let var = { 4 &gt; 6 ? 1 + 2 : 1 + 4 };\n</code></pre> <p>Here, the <code>1 + 2</code> will never be executed, since the condition is <code>false</code>. The compiled code would be the following:</p> <pre><code>let var = do {\n    if 4 &gt; 6 {\n        return 1 + 2;\n    }\n\n    return 1 + 4;\n};\n</code></pre>"},{"location":"pages/tutorial/start/configuration/","title":"Project Files","text":"<p>When you create and execute a new Ryna project, multiple files are created and it's good to know the meaning and structure of each one. Let's take a look at them.</p>"},{"location":"pages/tutorial/start/configuration/#project-files","title":"Project files","text":"<p>In a Ryna project there can be multiple files created automatically:</p> <ol> <li>main.ryna: entrypoint of the interpeter. This is the file that <code>ryna run</code> will execute.</li> <li>ryna_config.yml: contains everything the interpreter needs to execute a project. This includes the module's name,   version and paths to look for modules. This file should not be shared publicly.</li> <li>ryna_deps.yml: contains the name, dependencies and versions of the project. This file can be shared publicly and   a full ryna_config.yml file can be reconstructed from it if the required libraries are available.</li> <li>ryna_cache/main.rynac: contains a cached file that allows the execution of a module without recompiling.</li> <li>ryna_cache/prof.json: contains profiling information about the program.</li> </ol> <p>Let's take a look at each of them.</p>"},{"location":"pages/tutorial/start/configuration/#general-configuration","title":"General configuration","text":"<p>The ryna_config.yml file contains the following values:</p> <ul> <li>module_name: the module's name.</li> <li>version: the current module's version.</li> <li>hash: an automatically calculated value that summarizes the contents of a module in order to check if recompilation is necessary.</li> <li>build: a build script that will be executed when installing the library.</li> <li>module_paths: a list of strings that contains every path where the interpreter should look for modules when executing this project. They can contain   environment variables by using the format <code>${variable_name}</code>.</li> <li>modules: a map where the keys are the names of the modules that can be used inside the module and the values are objects with the following keys and values:<ul> <li>version: SemVer string that represents the version of the imported module.</li> <li>path: path pointing to the folder where the imported ryna_config.yml is located. </li> </ul> </li> </ul> <p>You can edit this however you want, but it is not recommended to modify the hash property. Also, the modules property should be handled using the <code>ryna add</code> command.</p>"},{"location":"pages/tutorial/start/configuration/#ryna-cache","title":"Ryna cache","text":"<p>There is not much to say about main.rynac other than when it is present, the program will not be recompiled as long as the hash is the same. Also, you can force recompilation by using the <code>--recompile</code> flag.</p>"},{"location":"pages/tutorial/start/configuration/#profiling-information","title":"Profiling information","text":"<p>Note: this file is still at a very experimental stage, so things may change and you might see some things that are not documented. Only the parts meant for non-developers will be explained here.</p> <p>The prof.json file is a JSON that contains many values, but the only ones that you should care about are the following:</p> <ul> <li>total_time: total execution time in nanoseconds.</li> <li>loc_time: map where the keys are the modules and the values are the times in nanoseconds spent executing that line in the module.</li> </ul>"},{"location":"pages/tutorial/start/create/","title":"Creating a Project","text":"<p>Once you have installed the Ryna interpreter, can begin creating projects. Let's see how this works.</p>"},{"location":"pages/tutorial/start/create/#create-a-project","title":"Create a project","text":"<p>The command to create a Ryna module is as follows:</p> <pre><code>ryna new &lt;args&gt;\n</code></pre> <p>Executing the command without arguments is enough to crate a project, since it will open a wizard that will allow you to input a name and configure everything. In any case, here are the arguments you may input:</p> Long name Short name Description <code>name</code> <code>n</code> Name of the project (skips name in wizard) <code>version</code> <code>v</code> Version of the project (skips version in wizard) <code>modules</code> <code>m</code> Modules path of the project (skips modules in wizard) <code>no-gitignore</code> <code>g</code> Skip default .gitignore creation"},{"location":"pages/tutorial/start/create/#adding-dependencies","title":"Adding dependencies","text":"<p>The command to add a dependency to a Ryna project is as follows:</p> <pre><code>ryna add\n</code></pre> <p>This will open up a wizard that will autocomplete the names and versions of the available libraries using the module paths. In any case, you can use the following args:</p> Long name Short name Description <code>name</code> <code>n</code> Name of the project (skips name in wizard) <code>version</code> <code>v</code> Version of the project (skips version in wizard)"},{"location":"pages/tutorial/start/create/#exporting-dependencies-file","title":"Exporting dependencies file","text":"<p>You can export an anonymous project file that you can share in public repositories with the following command:</p> <pre><code>ryna save-deps\n</code></pre> <p>This will create a ryna_deps.yml file in your project's directory using the data from ryna_config.yml.</p>"},{"location":"pages/tutorial/start/create/#importing-dependencies-file","title":"Importing dependencies file","text":"<p>You can import a ryna_deps.yml file with the following command:</p> <pre><code>ryna load-deps\n</code></pre> <p>This will create a ryna_config.yml file in your project's directory using the data from ryna_deps.yml. In order to do this the interpreter will use your default libraries path that you set with the <code>ryna setup</code> command and an optional extra libraries path. You can use the following args:</p> Long name Short name Description <code>modules</code> <code>m</code> Extra modules path of the project"},{"location":"pages/tutorial/start/create/#build-scripts","title":"Build scripts","text":"<p>You can run the build script (useful when testing) by using this command:</p> <pre><code>ryna build &lt;input_path&gt;\n</code></pre> <p>Here <code>input_path</code> is the folder of the project that you want to run and defaults to the current folder.</p>"},{"location":"pages/tutorial/start/install/","title":"Installation","text":""},{"location":"pages/tutorial/start/install/#installing-the-interpreter","title":"Installing the interpreter","text":"<p>Ryna is installed through <code>cargo</code>, Rust's package manager. You can see the crate here  and you can install it by using the following command:</p> <pre><code>cargo install ryna-language\n</code></pre> <p>After this, you can use the interpreter by using the <code>ryna</code> command, as you will see later in the tutorial. <code>cargo</code> should make sure that the interpreter is properly installed.</p>"},{"location":"pages/tutorial/start/install/#installing-from-source","title":"Installing from source","text":"<p>If you want to take a look at the lastest (unstable) features, you can clone the repository's develop branch and use the following command to run the interpreter:</p> <pre><code>cargo run &lt;args&gt;\n</code></pre> <p>If you want to install the current version, run the compilation command: </p> <pre><code>cargo build --release\n</code></pre> <p>Then, copy the corresponding binaries in the /target folder to some location inside your PATH env variable.</p>"},{"location":"pages/tutorial/start/install/#configuring-the-interpreter-important","title":"Configuring the interpreter [Important]","text":"<p>It is extremely recommended that you run this command just after you install it:</p> <pre><code>ryna setup\n</code></pre> <p>This will ask you for a default modules location where every library will be installed by default and create a global configuration file. Also, it will download the prelude libraries for you, which are some common functionalities that  you might need to use eventually, such as sets, math functions or special iterators.  </p>"},{"location":"pages/tutorial/start/libs/","title":"Installing Libraries","text":"<p>The Ryna interpreter allows you to install libraries from git repositories. Here are the commands that you can use in order to do that.</p>"},{"location":"pages/tutorial/start/libs/#installing-library-packs","title":"Installing library packs","text":"<p>A library pack is one or more libraries uploaded to a git repository (main branch). This is more correct that calling them a single library because a repository might have more than one in different folders for convenience (such as prelude). You can install a library pack using the following command:</p> <pre><code>ryna install &lt;REPO_URL&gt; &lt;PACK_NAME&gt;\n</code></pre> <p>This will clone the repository inside the configured modules folder. We assume that you have already executed <code>ryna setup</code>  before and completed the wizard. If the library contains a build script, you will be asked if you want to run it automatically. Please, be aware that you should only execute build scripts from trusted sources, since they may contain arbitrary commands.</p>"},{"location":"pages/tutorial/start/libs/#uninstalling-library-packs","title":"Uninstalling library packs","text":"<p>In order to uninstall a library pack you have to use the following command:</p> <pre><code>ryna uninstall &lt;PACK_NAME&gt;\n</code></pre> <p>This removes the library pack from the configured modules folder.</p>"},{"location":"pages/tutorial/start/run/","title":"Executing and Profiling","text":"<p>Once you have created a project, you will want to run it. For this, you can use the following command.</p>"},{"location":"pages/tutorial/start/run/#running","title":"Running","text":"<p>The command to run a Ryna module is as follows:</p> <pre><code>ryna run &lt;input_path&gt;\n</code></pre> <p>Here <code>input_path</code> is the folder of the project that you want to run and defaults to the current folder. You may pass the following arguments to the command:</p> Long name Short name Description <code>recompile</code> <code>r</code> if passed, do not cache compilation <code>profile</code> <code>p</code> if passed, the interpreter will instrument the code before running it in order to generate a prof.json file <code>optimize</code> <code>o</code> if passed, the interpreter will try to optimize the code in order to run it faster (recommended) <code>test</code> <code>o</code> if passed, the interpreter will run the functions marked as tests instead of the main program"},{"location":"pages/tutorial/start/run/#documenting","title":"Documenting","text":"<p>You can automatically generate the documentation for your project by using the following command:</p> <pre><code>ryna docs &lt;input_path&gt;\n</code></pre> <p>Here <code>input_path</code> is the folder of the project that you want to document.</p>"},{"location":"pages/tutorial/steps/algebraic/","title":"Algebraic Types","text":"<p>Algebraic types are a concept that has been hovering around functional programming languages for a long time. There are multiple  resources online where you can get a very deep understanding on what they mean and what they can be used for, so here we will only give a very short introduction to the concept. Also, you can check the Learn by example section at the end of the tutorial in  order to see some applications.</p> <p>The mechanics of these types are very simple, you have sum types and product types. The first ones allow you to define a  tagged union of data (i.e. data that can be from any of the types that conform the sum, but only one at a time). The second one is what we would understand as a tuple, which holds multiple elements in order. The interesting thing about these is that, when  you allow recursion (such as Ryna does), you can create complex data structures called Algebraic Data Types. These can be extremely useful in functional contexts, but simpler types can also be very useful when expressing complex algorithms.</p> <p>In Ryna, sum types are expressed using <code>|</code>, so a value that is either an <code>Int</code> or a <code>Float</code> would be expressed using <code>Int | Float</code>. Of course, you can add as many variants (types in the sum) as you want. On the other hand, product types are expressed using tuple-like syntax, so <code>(Int, Float)</code> would be a tuple containing an <code>Int</code> and a <code>Float</code>, in that very same order. You can also add as many types as you want to a tuple.</p> <p>As you might expect, you can mix these with everything we have seen before. All these are valid Ryna types:</p> <pre><code>Int | &amp;Float         // Either an Int or a constant reference to a Float\n&amp;(Int | Bool)        // A constant reference to either an Int or a Bool\n@(String, Int)       // Mutable reference to a tuple of a String and an Int\nBool | &amp;(Bool, Bool) // Either a Bool or a constant reference to a tuple of two Bools\n</code></pre> <p>Even if these sound very expressive, this is not everything there is to know abot the Ryna type system. There are some special types that we need to talk about before we dive into generics.</p>"},{"location":"pages/tutorial/steps/annot/","title":"Syntax and usage","text":"<p>Many programming languages allow the user to add extra information to the structures they define by using annotations.  You can also use them in Ryna. Let's see how.</p>"},{"location":"pages/tutorial/steps/annot/#syntax","title":"Syntax","text":"<p>An annotation in Ryna consists on a name, some positional arguments and some named arguments. Depending on the  particular annotation, some arguments might be needed or optional. Also, you can use multiple annotations on a single definition.  Here is the syntax:</p> <pre><code>// These two are equivalent\n\n@annotation_name\nfn function_name() {\n    // ...\n}\n\n@annotation_name()\nfn function_name() {\n    // ...\n}\n\n// This one has positional arguments\n\n@annotation_name(\"argument 0\", \"argument 1\")\nfn function_name() {\n    // ...\n}\n\n// This one has named arguments\n\n@annotation_name(\n    name_0: \"argument 0\", \n    name_1: \"argument 1\"\n)\nfn function_name() {\n    // ...\n}\n\n// This one has both\n\n@annotation_name(\n    \"Positional arg 0\",\n    name_0: \"argument 0\", \n    name_1: \"argument 1\",\n    \"Positional arg 1\" // You can insert named arguments between positional ones \n)\nfn function_name() {\n    // ...\n}\n</code></pre>"},{"location":"pages/tutorial/steps/annot/#usage","title":"Usage","text":"<p>An annotation in Ryna can be put just before any class, syntax, function, operation or interface definition. Also, you can annotate any function or operation inside an interface definition. In later sections we will take a look at every  available annotations defined in the interpreter.</p>"},{"location":"pages/tutorial/steps/annot_docs/","title":"Documenting your modules","text":"<p>Ryna also allows you to automatically document your modules by using annotations. Let's take a look at how.</p>"},{"location":"pages/tutorial/steps/annot_docs/#documenting-parts-of-your-code","title":"Documenting parts of your code","text":"<p>In order to document some defintion in your code, you have to use the <code>@doc</code> annotation. The first positional argument will represent the general description of the entity you are documenting and the second one will refer to the return value if there is one (interfaces, for example, do not have one). Also, you can use named arguments to document the semantics of attributes and arguments, using the same name. Let's take a look at an example extracted from prelude:</p> <pre><code>@doc(\n    \"Fills every available position in an array with a given value. The filling starts in the current `len`.\",\n    array: \"the array to fill.\",\n    value: \"the value to fill the available positions with.\",\n    \"An array where every position starting from the previous `len` is `value`\"\n)\nfn&lt;T&gt; fill(array: @Array&lt;'T&gt;, value: 'T) -&gt; @Array&lt;'T&gt; {\n    while array.capacity() &gt; array.len() {\n        array.push(*value);\n    }\n\n    return array;\n}\n</code></pre> <p>The used as arguments contain markdown and will be rendered as such when the documentation is generated.</p>"},{"location":"pages/tutorial/steps/annot_docs/#generating-documentations","title":"Generating documentations","text":"<p>In order to generate the documentation you have to use the use the following command:</p> <pre><code>ryna docs &lt;PATH&gt;\n</code></pre> <p>The documentation will be generated inside a docs folder at the root of your project.</p>"},{"location":"pages/tutorial/steps/annot_test/","title":"Testing your modules","text":"<p>Ryna allows you to annotate functions in order to test your modules. Let's take a look at how.</p>"},{"location":"pages/tutorial/steps/annot_test/#creating-tests","title":"Creating tests","text":"<p>In order to create a test you have to annotate a function with the <code>@test</code> annotation, which takes no arguments.  This function must take no arguments and must return a logical value. The test will be considered successful if and only if the function returns <code>true</code>. Let's take a look at an example extracted from prelude:</p> <pre><code>@test\nfn fill_test() -&gt; Bool {\n    let res = arr_with_capacity&lt;Int&gt;(3);\n    res.fill(100);\n\n    for i in res {\n        if i != 100 {\n            return false;\n        }\n    }\n\n    return true;\n}\n</code></pre> <p>This test should always pass, since it's filling an array with a value and then checking the contents, but this can be useful when changing your code or when programming with TDD. </p>"},{"location":"pages/tutorial/steps/annot_test/#testing","title":"Testing","text":"<p>In order to execute the tests inside your module you have to use the use the following command:</p> <pre><code>ryna run &lt;PATH&gt; --test\n</code></pre> <p>You can also add optimization and recompilation flags, as seen in the Getting Started section.</p>"},{"location":"pages/tutorial/steps/basics/","title":"The Basics","text":"<p>Ryna is an imperative, strongly-typed programming language with many common features. Here We will explain the main ones. All these should be enough to get you started writing basic code, but more complex features will be analyzed later in their own respective sections.</p>"},{"location":"pages/tutorial/steps/basics/#literals","title":"Literals","text":"<p>One of the main ways you can create values is by writing down explicit constants that the compiler will understand as basic types. These are called literals and are a very important concept in many languages, but more so in Ryna. Here are all the literals that tthe language supports.   </p>"},{"location":"pages/tutorial/steps/basics/#integers","title":"Integers","text":"<p>Integers can be inputted in Ryna in a similar way as other languages:</p> <pre><code>881452      // Basic integer (no size limit)\n-32         // Negative integers are also literals\n0b1000110   // Binary integers (70 in this case)\n0xFF1A      // Hexadecimal integers (65306 in this case)\n</code></pre> <p>All these values are compiled to <code>Int</code> values.</p>"},{"location":"pages/tutorial/steps/basics/#floating-point-numbers","title":"Floating Point numbers","text":"<p>Floating point numbers are more or less the same as in other languages:</p> <pre><code>1.56        // Basic float\n-67.2       // Negative floats are also literals\n1e10        // Scientific notation is allowed\n2E-5\n1.5e2\n-2.2E-8\n</code></pre> <p>All these values are compiled to <code>Float</code> values.</p>"},{"location":"pages/tutorial/steps/basics/#logical-values","title":"Logical values","text":"<p>The only logical literals Ryna supports are <code>true</code> and <code>false</code>. They are compiled to <code>Bool</code> values.</p>"},{"location":"pages/tutorial/steps/basics/#strings","title":"Strings","text":"<p>Strings in Ryna are UTF-8 encoded and are inputted by using double quotes with the possibility of escape sequences. These would be some examples:</p> <pre><code>\"This is an example\"\n\n\"This is an example with \\t tabs and line \\n jumps\"\n\n\"Also, you \ncan have\nmultiline \nstrings\"\n</code></pre> <p>All these values are compiled to <code>String</code> values.</p>"},{"location":"pages/tutorial/steps/basics/#characters","title":"Characters","text":"<p>Characters do not exist in Ryna as a class, but they can be used as <code>Int</code> code points:</p> <pre><code>'w' // This is equal to 119\n</code></pre> <p>This can be used when iterating over code points.</p>"},{"location":"pages/tutorial/steps/basics/#variables","title":"Variables","text":"<p>In contrast to functional languages, Ryna does have support for variables and they are used as much as in any other imperative language. Constants are not implemented for now, but they might be introduced in a future release.</p>"},{"location":"pages/tutorial/steps/basics/#definition","title":"Definition","text":"<p>The syntax for variable definitions is as follows:</p> <pre><code>let name: Type = expression;\n</code></pre> <p>In <code>let</code> statements, <code>name</code> can be any alphanumeric identifier that does not begin with a number (\"_\" is also allowed),  <code>Type</code> can be any valid type of the ones seen in the Type System section and <code>expression</code> can be anything that is not a  statement. These would be some valid examples:</p> <pre><code>let example_1: Int = 3 + 6;     // Simple definition\nlet example_2 = 3 + 6;          // Here the Int type is inferred\nlet example_3 = \"Test\";         // A String type is inferred\n</code></pre> <p>Any variable defined in the global context (top level of the code) will be accessible from functions, but note that they must be defined before being called.</p>"},{"location":"pages/tutorial/steps/basics/#assignment","title":"Assignment","text":"<p>When you have already defined a variable, you can replace its value by using the <code>=</code> operator: </p> <pre><code>let example: Int = 3 + 6;\n\nexample = 5;      // Replace the value by 5\nexample = true;   // ERROR: Bool is not bindable to Int\n</code></pre>"},{"location":"pages/tutorial/steps/basics/#getting-values","title":"Getting values","text":"<p>To get the value of a variable, just use its name in the code. Note that you will get a Reference to the value instead of the value to prevent the user from making unnecessary copies:</p> <pre><code>let big = \"Imagine this is a very big string ...\";\n\nlet big_2: String = big;            // ERROR: @String is not bindable to String\nlet big_3: @String = big;           // Keeps a reference\nlet big_4: String = big.deref();    // Copies the original data\nlet big_5: &amp;String = big.demut();   // Keeps a constant reference\n</code></pre>"},{"location":"pages/tutorial/steps/basics/#reference-assignment","title":"Reference assignment","text":"<p>Sometimes you might need to change the underlying values of a mutable reference. An example of this would be trying to change an element inside an array or mutating a class instance. For these cases you can use the <code>:=</code> operator:</p> <pre><code>/*\n    Imagine a class Example that has an Int \n    attribute called attribute_1\n*/\n\nlet example: Example = some_class_instance;\n\nexample.attribute_1() := 5;     // This is only allowed using this operator\nexample.attribute_1() := \"Test\" // ERROR: String is not bindable to Int\n</code></pre>"},{"location":"pages/tutorial/steps/basics/#functions","title":"Functions","text":"<p>You can also use functions in Ryna, as you might expect. Functions are called using the parentheses syntax used in most imperative languages,  including angle brackets in the case of generics.</p>"},{"location":"pages/tutorial/steps/basics/#operations","title":"Operations","text":"<p>Just as most programming languages, Ryna has operators and operations. These encode operations with one, two o even more expressions called operands. Ryna supports four kind of operators:</p> <ol> <li>Prefix operators: the operator comes before a single expression (example: <code>-5</code>).</li> <li>Postfix operators: the operator comes after a single expression (example: <code>5!</code>).</li> <li>Binary (infix) operators: the operator comes betwwen two expressions (example: <code>1 + 2</code>).</li> <li>N-ary operators: the operator has an opening and a closing delimiter. Operands are before and inside the delimiters (example: <code>mat[4, 5]</code>).</li> </ol> <p>All these operators and operations can be defined in a similar way as functions. The syntax for generics varies depending on the type of operator and will be explained in their corresponding section.</p>"},{"location":"pages/tutorial/steps/basics/#flow-control","title":"Flow control","text":"<p>These are the flow-control operations that are allowed in Ryna.</p>"},{"location":"pages/tutorial/steps/basics/#if-else","title":"If-else","text":"<p>The language supports if-else control flow with the following syntax:</p> <pre><code>// Else ifs and elses are optional\nif condition {\n    [...]\n} else if condition {\n    [...]\n} else {\n    [...]\n}\n</code></pre> <p>conditions must evaluate to <code>Bool</code>.</p>"},{"location":"pages/tutorial/steps/basics/#while","title":"While","text":"<p>While loops have the following syntax:</p> <pre><code>while condition {\n    [...]\n}\n</code></pre> <p>conditions must also evaluate to <code>Bool</code>. You can <code>break</code> and <code>continue</code> in while loops.</p>"},{"location":"pages/tutorial/steps/basics/#for","title":"For","text":"<p>For loops are the most complicated of the three. To begin with, you need an <code>Iterable</code> object, which is defined as one that implements the <code>Iterable</code> interface (more information about interfaces in their section). After this, you can write the following:</p> <pre><code>// container must implement Iterable\nfor i in container {\n    [...]\n}\n</code></pre> <p>if you want to make a custom class iterable you have to implement that Interface manually. You can <code>break</code> and <code>continue</code> in for loops.</p>"},{"location":"pages/tutorial/steps/binding/","title":"Binding Rules","text":"<p>Now that we have seen all available types, we will see the last section on the type system: the binding rules. These specify whether or  not you can put a value of a given type inside a variable of another type. Most of these are pretty straightforward, but listing them makes things easier on complex cases.</p> <p>A type <code>A</code> is bindable to type <code>B</code> if and only if one of the following cases apply:</p> <ol> <li><code>B</code> is <code>*</code>.</li> <li><code>A</code> and <code>B</code> are the same.</li> <li>Both <code>A</code> and <code>B</code> are constant references and their inner types are bindable.</li> <li>Both <code>A</code> and <code>B</code> are mutable references and their inner types are bindable.</li> <li><code>A</code> is a structural type and its alias is bindable to <code>B</code>.</li> <li><code>B</code> is a structural type and <code>A</code> is bindable to its alias.</li> <li><code>A</code> is a template and <code>B</code> follows its constraints and the substitution is not incoherent with the rest.</li> <li><code>B</code> is a template and <code>A</code> follows its constraints and the substitution is not incoherent with the rest.</li> <li><code>A</code> is a sum type and all its variants are bindable to <code>B</code></li> <li><code>B</code> is a sum type and <code>A</code> is bindable to any of its variants.</li> <li>Both <code>A</code> and <code>B</code> are product types with the same length and every type <code>A_i</code> is bindable to <code>B_i</code>.</li> <li>Both <code>A</code> and <code>B</code> are the same parametric type with the same class and every type parameter <code>A_i</code> is bindable to the type parameter <code>B_i</code>.</li> <li>Both <code>A</code> and <code>B</code> are function types and both their argument types and return types are bindable.</li> </ol> <p>As you can see, checking whether or not two types are bindable is a recursive process, but the ideas are very intuitive given the descriptions in their corresponding sections. Now that we have defined one of the key aspects of Ryna, we will begin explaining how to use the language.</p>"},{"location":"pages/tutorial/steps/block_macros/","title":"Block Macros","text":"<p>Another case we need to show is when your desired macro functionality needs to interact with the current context or when you want to encapsulate multiple lines of code inside a single statement. For this purpose, you can use block macros.</p>"},{"location":"pages/tutorial/steps/block_macros/#syntax","title":"Syntax","text":"<p>A block macro can be created in Ryna using this syntax:</p> <pre><code>syntax block macro_name from NDL_Pattern {\n    [...]\n}\n</code></pre> <p>The main difference with expression and function macros is that these can only be used as statements, so they do not count as valid expressions. Code such as <code>1 + &lt;some_block_macro&gt;</code> is not valid Ryna. You need to use expression and function macros for that.</p> <p>An example of a block macro that creates an early return would be the following (note that we have to escape the closing brace of the if statement in order for the macro body to be correct):</p> <pre><code>syntax block early_return from \"ret#\" Arg(1{l}, name) \";\" {\n    if $name &lt; 5 {\n        return false;\n    \\}\n}\n\n// This function ...\nfn test(var) -&gt; Bool {\n    ret#var;\n\n    return true;\n}\n\n// ... compiles to this\nfn test(var) -&gt; Bool {\n    if var &lt; 5 {\n        return false;\n    }\n\n    return true;\n}\n</code></pre> <p>Of course, you can generate as many lines of code as you want with a block macro, but this is just a simple example of what you can do.</p>"},{"location":"pages/tutorial/steps/builtin/","title":"Built-in Basic Types","text":"<p>The main building blocks of the Ryna type system are what we will call basic types. These represent kinds of data that can be stored. As you might expect, Ryna provides an implementation for some basic types, which are summarized in the following table:</p> Name Description <code>Int</code> Unbounded size integer <code>Float</code> 64 bits floating point number <code>Bool</code> Value that can be either true or false <code>String</code> UTF-8 encoded text <code>File</code> Handle that points to a file and allows reading and writing <p>These types are not much by themselves, but in the following sections we will see how we can combine them in order to make more complex types. </p>"},{"location":"pages/tutorial/steps/classes/","title":"Defining Classes","text":"<p>One of the main features of any Object Oriented Language is the definition of classes. Ryna supports them, so let's take a look at the syntax and semantics.</p>"},{"location":"pages/tutorial/steps/classes/#syntax","title":"Syntax","text":"<p>You can define new classes using the following syntax:</p> <pre><code>// Simple\nclass ClassName {\n    attr_1: Type_1;\n    attr_2: Type_2;\n    [...]\n}\n\n// With generics\nclass ClassName&lt;T&gt; {\n    attr_1: Type_1;\n    attr_2: Type_2;\n    [...]\n}\n</code></pre> <p>If you define a new class anywhere in your code, you can use its name as a type:</p> <pre><code>let var: ClassName = expression;\n</code></pre>"},{"location":"pages/tutorial/steps/classes/#usage","title":"Usage","text":"<p>When you create a new class, some utility functions are defined automatically in order for you to be able to use the class effectively.</p>"},{"location":"pages/tutorial/steps/classes/#constructor","title":"Constructor","text":"<p>A class's definition implies the creation of a constructor function that takes as many parameters as attributes and creates an instance of that class. The parameters are ordered from top to bottom. Let's see an example:</p> <pre><code>class ExampleClass {\n    attrib_1: Int;\n    attrib_2: &amp;Int;\n    attrib_3: @Int;\n}\n\nlet a = 1;\nlet b = 2;\n\nlet ex = ExampleClass(1, a.demut(), b);\n</code></pre>"},{"location":"pages/tutorial/steps/classes/#accessors","title":"Accessors","text":"<p>Each attribute can be accessed and modified using the syntax you would expect. Attributes are returned as references to allow modifications.  Following the previous example, you could access and modify <code>ExampleClass</code>'s attributes like this:</p> <pre><code>ex.attrib_1; // Returns @Int\nex.attrib_2; // Returns &amp;Int\nex.attrib_3; // Returns @Int\n\nlet a = 10;\n\nex.attrib_1 = 5;         // Can be assigned an Int\nex.attrib_2 = a.demut(); // Can be assigned an &amp;Int\nex.attrib_3 = a;         // Can be assigned an @Int\n</code></pre>"},{"location":"pages/tutorial/steps/code_macros/","title":"Macro Code Execution","text":"<p>In the Function Macros section we mentioned that Ryna has a code generation pattern that executes code. Since its complexity is far from the rest, we will dedicate this section to explaining how it works.</p>"},{"location":"pages/tutorial/steps/code_macros/#syntax","title":"Syntax","text":"<p>The syntax of this pattern is simple:</p> <pre><code>{| inner_pattern |}\n</code></pre> <p>You can put any macro pattern you want inside those braces and the resulting text will be interpreted as Ryna code. The generated code  will execute normally, even importing libraries if necessary, but you will have access to a special function not available otherwise: the <code>emit</code> function.</p> <p>This funtion, which takes as a parameter a single <code>String</code>, will send that string to a buffer that will accumulate everything emited  throughout the execution of the code. After the execution ends, the buffer will be appended to the code generated by the macro. This is essentially the same as procedural macros in Rust.</p>"},{"location":"pages/tutorial/steps/code_macros/#examples","title":"Examples","text":"<p>Lets see a basic example that creates the expression <code>1 + 1</code>. In order to do this you do not need compile time code execution, but it will allow us to  illustrate how they work. You could use the following:</p> <pre><code>syntax expr one_plus_one from \"Example\" {\n    {| emit(\"1 + 1\") |}\n}\n\n// Use it like this ...\nprint(Example);\n\n// ... which compiles to this\nprint(1 + 1);\n</code></pre> <p>Of course, this is not very interesting because this macro has no interaction with the pattern that was matched. This can be changed easily by using different inner patterns, so let's make a more complex example:</p> <pre><code>syntax expr n_plus_m from Arg(1{d}, a) \"plus\" Arg(1{d}, a) {\n    {|\n        let a = \"$a\";\n        let b = \"$b\";\n\n        emit(*a);\n        emit(\" + \");\n        emit(*b);\n    |}\n}\n\n// Use it like this ...\nprint(7plus32);\n\n// ... which compiles to this\nprint(7 + 32);\n</code></pre> <p>As you can imagine, this opens up possibilities a lot when using macros, since you can even import libraries inside them. You can see an extreme example where you embed an esoteric language inside Ryna using these macro patterns in the Learn by example section.</p>"},{"location":"pages/tutorial/steps/def_functions/","title":"Defining Functions","text":"<p>Let's now take a look at the syntax and semantics for defining new functions in Ryna.</p>"},{"location":"pages/tutorial/steps/def_functions/#syntax","title":"Syntax","text":"<p>You can define and use a function using the following syntax:</p> <pre><code>// Definition\nfn funtion_name_1(param_1: Type_1, param_2: Type_2, ...) -&gt; Return_type {\n\n    [...]\n\n    return some_expression;\n}\n\n// Usage\nlet variable: Return_type = funtion_name_1(something_1, something_2);\n</code></pre> <p>Of course, you can have as many <code>return</code> statements as you want (or none at all if your function does not return anything), but  this is a simple example. Now let's modify this code to create a generic function:</p> <pre><code>// Definition\nfn&lt;T, G&gt; funtion_name_2(param_1: Type_1, param_2: Type_2, ...) -&gt; Return_type {\n\n    [...]\n\n    let variable_1: 'T = something;\n    let variable_2: Array&lt;'G&gt; = something;\n\n    [...]\n\n    return some_expression;\n}\n\n// Explicit usage\nlet variable_1: Return_type = funtion_name_2&lt;Type_3, Type_4&gt;(something_1, something_2);\n\n// Type parameter inference (when unambiguous)\nlet variable_2: Return_type = funtion_name_2(something_1, something_2);\n</code></pre> <p>Here you can see that putting <code>&lt;T, G&gt;</code> after the <code>fn</code> keyword in the definition defines the templates <code>T</code> and <code>G</code> inside the function body. They cannot be used outside the function body.</p> <p>Note: the <code>&lt;T, G&gt;</code> syntax might change to <code>&lt;'T, 'G&gt;</code> in a future release for ease of highlighting and uniformization.</p>"},{"location":"pages/tutorial/steps/def_functions/#examples","title":"Examples","text":"<p>Let's create some common examples to see how functions work in this language. First off, let's create two factorial functions, a recursive and an iterative one:</p> <pre><code>fn factorial_recursive(n: Int) -&gt; Int {\n    if n == 1 {\n        return 1;\n    }\n\n    return n * factorial_recursive(n - 1);\n}\n\nfn factorial_iterative(n: Int) -&gt; Int {\n    let res = 1;\n\n    while n &gt; 1 {\n        res = res * n;\n        n = n - 1;\n    }\n\n    return res.deref();\n}\n</code></pre> <p>Now let's dive into generics and make a function that counts how many elements in an array are equal to one given as a parameter:</p> <pre><code>fn&lt;T&gt; count(array: &amp;Array&lt;'T&gt;, elem: &amp;'T) -&gt; Int {\n    let res = 0;\n\n    for i in array {\n        if i == elem {\n            res = res + 1;\n        }\n    }\n\n    return res.deref();\n}\n</code></pre> <p>As a final touch, note that functions and operations can access global variables:</p> <pre><code>let global_var = 5;\n\nfn double_global() -&gt; Int {\n    return global_var * 2;\n}\n</code></pre>"},{"location":"pages/tutorial/steps/destructors/","title":"Destructors","text":"<p>When building a Ryna library that uses FFI, you will sometimes want to expose native structures to the Ryna side. For this, you can use a wrapped <code>Pointer</code> that contains an adapted API, but there is a catch: the memory to which the pointer points to will not be freed upon destroying the object on the Ryna side. This is due to many reasons, but you can fix this by defining a custom destructor. Let's take a look at how you can do this.</p>"},{"location":"pages/tutorial/steps/destructors/#what-is-a-destructor","title":"What is a destructor?","text":"<p>A destructor is a special function that takes care of freeing the memory of an object. They are needed in programming languages with manual memory management such as  C++, but they are rarely used (or even available) in languages with automatic memory management. These functions have some special properties and need to adhere to certain standards depending on the language. Ryna is no special case for this.</p> <p>In this language, destructors are defined by means of the <code>Destroyable</code> interface, which contains a <code>destroy(obj: &amp;Self)</code> function. When you implement this interface for a type, you are telling the interpreter that it has to destroy an object of this type upon closing a context using the function you provided. You should call  the <code>LibraryFunction</code> that frees the memory inside <code>destroy</code>. Here is a small toy example:</p> <pre><code>class Test {\n    name: String;\n}\n\nimplement Destroyable for Test;\n\nfn destroy(obj: &amp;Test) {\n    print(\"Destroying \" + obj.name + \"\\n\");\n}\n\nif some_condition {\n    let t1 = Test(\"obj1\");\n\n    // Some more code\n    // ...\n\n    // t1 will be destroyed here\n}\n\n// here t1 no longer exists\n</code></pre>"},{"location":"pages/tutorial/steps/destructors/#destructor-generation","title":"Destructor generation","text":"<p>Some types might need to be destroyed even though they do not implement <code>Destroyable</code>. This is the case of classes that contain elements that do implement it (<code>Array</code>s,  for example). These cases are automatically detected by the compiler and their destructors are generated, so you do not need to implement these manually:</p> <pre><code>// Using the code from the previous snippet\n\nif some_other_condition {\n    let v = arr&lt;Test&gt;();\n    v.push(Test(\"obj1\"));\n    v.push(Test(\"obj2\"));\n    v.push(Test(\"obj3\"));\n\n    // v is destroyed here, along with each internal element\n}\n\n// v no longer exists here\n</code></pre> <p>Also, sometimes you will have classes that need a custom destructor but that also have other attributes that have custom destructors. For these cases, you need to let the compiler generate the destructor by wrapping every pointer. For example, this is forbidden by the compiler:</p> <pre><code>// Using the code from the first snippet\n\nclass Test2 {\n    attr_1: Test;\n    attr_2: Pointer; // This attribute needs a custom destructor\n}\n\nfn destroy(obj: &amp;Test2) {\n    // ...\n}\n\n// ERROR: a class that needs a generated destructor cannot implement Destroyable\nimplement Destroyable for Test2;\n</code></pre> <p>Instead, you have to do the following:</p> <pre><code>// Again, using the code from the first snippet\n\nclass NativeStruct {\n    attr: Pointer\n}\n\nimplement Destroyable for NativeStruct;\n\nfn destroy(obj: &amp;NativeStruct) {\n    // Free the native memory here\n}\n\nclass Test2 {\n    attr_1: Test;\n    attr_2: NativeStruct; // Now the destructor is generated\n}\n</code></pre>"},{"location":"pages/tutorial/steps/destructors/#destructor-locations","title":"Destructor locations","text":"<p>Data in general is not guaranteed to be freed in Ryna at the end of contexts. Ryna only frees the variables used inside a function's body after every execution and when ending the execution. When you are using destructors, this is no longer true. Instead, the values are freed in these cases:</p> <ul> <li>When exiting a function via <code>return</code>.</li> <li>When exiting a context (<code>do</code>, <code>if</code>, <code>else</code>, <code>while</code> and <code>for</code>).</li> <li>When executing a lone expression that will not be stored.</li> </ul> <p>So you have to take into account that memory management is a little bit more strict when dealing with values that implement the <code>Destroyable</code> interface.</p>"},{"location":"pages/tutorial/steps/do_blocks/","title":"Do Blocks","text":"<p>There is a final function-related issue that might happen when you code in Ryna. It can be solved with a new feature called do blocks,  so let's take a look:</p>"},{"location":"pages/tutorial/steps/do_blocks/#the-problem","title":"The problem","text":"<p>Imagine you want to create a variable called <code>var</code> and you want to assign it the value <code>a</code> or <code>b</code> depending on a condition <code>c</code>. Your first instict might be doing something like this:</p> <pre><code>let var;\n\nif c {\n    var = a;\n\n} else {\n    var = b;\n}\n</code></pre> <p>The problem is, Ryna does not allow to declare a variable without initializing it. One way to solve this would be using a dummy value <code>d</code>: </p> <pre><code>let var = d;\n\nif c {\n    var = a;\n\n} else {\n    var = b;\n}\n</code></pre> <p>But this creates two problems:</p> <ol> <li>Your program does unnecesary steps, so performance may suffer.</li> <li><code>d</code> might not be available in generic contexts.</li> </ol> <p>You cannot do this, so you will have to use do blocks;</p>"},{"location":"pages/tutorial/steps/do_blocks/#do-blocks","title":"Do blocks","text":"<p>A do block can be understood as a function body that will only be executed once. You could solve the previous problem like this:</p> <pre><code>let var = do {\n    if c {\n        return a;\n\n    } else {\n        return b;\n    }\n};\n</code></pre> <p>the syntax is self-explanatory and the semantics are the same as a function body, but without calls to any methods. Also, they allow you to access the context above it (unlike lambdas or regular functions).  These are the blocks that are used to compile function macros, but we will take a look at that in a later section. </p>"},{"location":"pages/tutorial/steps/esp_functions/","title":"Special Functions","text":"<p>We will take a small detour before we continue explaining features and talk about special functions. When we say special we mean that the function does not just compute something, but affects the interpreter in some way. These functions are not many, but are needed in order to create some complex behaviours or in order to minimize the memory usage of a program. Here is a table with these functions:</p> Name Description <code>print</code> Takes a single argument and prints it to stdout <code>panic</code> Takes a single <code>String</code> and prints it to stderr, then exits the program <code>swap</code> Takes a two arguments of the same type and swaps their contents to a memory level <code>move</code> Takes a single mutable reference and returns a dereferenced value. This renders the value it pointed to invalid and the interpreter will error on access <code>as</code> Returns the argument coerced to the type of the type argument if it is the same type, else the interpreter will throw an error <code>is</code> Checks if the argument is of the type given in the type argument. You should use this before using the <code>as</code> function"},{"location":"pages/tutorial/steps/expr_macros/","title":"Expression Macros","text":"<p>Sometimes you want to use macros to create small code transformations that result in an expression (ie. not an if-else, for, while or definition).  For this purpose, you can use the second type of macro that Ryna has: expression macros. Let\"s see how they work.</p>"},{"location":"pages/tutorial/steps/expr_macros/#syntax","title":"Syntax","text":"<p>An expression macro can be created in Ryna using this syntax:</p> <pre><code>syntax expr macro_name from NDL_Pattern {\n    [...]\n}\n</code></pre> <p>You can see that the syntax is almost the same, but contains the <code>expr</code> keyword. The other thing that changes is how they are compiled internally:</p> <pre><code>syntax expr double_integer from \"Dbl\" Arg(1{d}, n) {\n    $n + $n\n}\n\n// This macro ...\nprint(Dbl6);\n\n// ... is compiled to this\nprint(6 + 6);\n</code></pre> <p>You might be worrying about operator precedence by looking at this, but the interpreter ensures that the expression inside the macro is kept as-is, so you could use it like this:</p> <pre><code>// This macro ...\nprint(2 * Dbl6);\n\n// ... is compiled to this ...\nprint(2 * (6 + 6));\n\n// ... not to this\nprint(2 * 6 + 6);\n</code></pre>"},{"location":"pages/tutorial/steps/ffi/","title":"Foreign Function Interface","text":"<p>Ryna is an interpreted language that runs on a custom VM. This means that, while it makes it easier to mantain consistent behaviours in different environments, the VM may lack the ability to do certain low level tasks. Also, sometimes you want to use specialized structures for tasks that need to be as efficient as possible. An example of this is the NumPy Python library, which is coded in C for maximum performance.</p> <p>As you might expect, you can do the same in Ryna by means of dynamic libraries. Let's take a look at how it works.</p>"},{"location":"pages/tutorial/steps/ffi/#libraries-and-functions","title":"Libraries and Functions","text":"<p>There are two classes included in the interpreter by default called <code>Library</code> and <code>LibraryFunction</code>. These allow you to call dynamic libraries using the following functions:</p> <pre><code>// Load the library\nlet library = load_library(\"Path-to-your-dynamic-library\");\n\n// Load the functions inside the library\nlet fun1 = lib.demut().get_function(\"function-name-1\");\nlet fun2 = lib.demut().get_function(\"function-name-2\");\nlet fun3 = lib.demut().get_function(\"function-name-3\");\n\n// Call the functions\nlet res1 = fun1.demut().call(arg1, arg2, ...);\nlet res2 = fun2.demut().call(arg1, arg2, ...);\nlet res3 = fun3.demut().call(arg1, arg2, ...);\n</code></pre> <p>Now, this mechanism relies on the fantastic libloading Rust crate, so the string you use as an input to the <code>load_library</code> function can automatically infer the extension of the library (.dll in Windows, for example).</p> <p>Also, sometimes the library you are trying to load will be located inside the project's directory. You can use the <code>$MODULE_PATH</code> macro to insert a <code>String</code> containing the path to the folder in which the ryna_config.yml is located. </p>"},{"location":"pages/tutorial/steps/ffi/#argument-compatibility","title":"Argument compatibility","text":"<p>As you might expect, passing Ryna objects to other programming languages is not an straightforward task. Only a subset of the original ryna types are supported and you cannot pass custom classes as arguments. The compiler will let you do it, but it will crash in runtime. These are the types that are supported:</p> <ul> <li><code>Bool</code>: translated as a 1 or a 0.</li> <li><code>Int</code>: translated as a 64 bit signed integer.</li> <li><code>Float</code>: translated as a double (64 bit floating point number).</li> <li><code>String</code>: translated as a <code>Pointer</code>. </li> <li><code>Pointer</code>: passed as-is. The width depends of the architecture.</li> </ul> <p>Take into account that <code>Pointer</code>s are not typed, so you should wrap them in custom classes in order to know what they are. Also, there is no way to dereference a value of this type, they are only in Ryna to allow the user to create data structures that rely on FFI.</p>"},{"location":"pages/tutorial/steps/ffi/#build-scripts","title":"Build scripts","text":"<p>If you happen to be creating a Ryna library that you want to distribute and it relies on FFI, you can add a custom build script to your library so the <code>ryna install</code> and the <code>ryna build</code> commands execute it by default. For this, use the build key in the ryna_config.yml file.</p>"},{"location":"pages/tutorial/steps/first/","title":"Introduction","text":"<p>Now that you have the Ryna interpreter installed, you can start creating  programs in this language, but you should know some basic facts about it first. In this step by step guide we will explain almost everything there is to know about Ryna, but be aware that the language is in a very young stage, so things may change.</p>"},{"location":"pages/tutorial/steps/first/#main-features-and-focus","title":"Main features and focus","text":"<p>The main focus of Ryna is to allow the user to write very expressive code by means of powerful syntax extension capabilities. These range from custom literals to a very expressive macro system that makes extending the syntax much easier than in other languages.  This makes the language vary syntactically depending on which libraries you import into your program and which features you select from them.</p> <p>Be aware that this could be potentially a bad thing if it is not treated carefully. For example, this could mean absolute chaos for a dynamically typed language such as Python. Ryna is designed so there are enough safety measures to ensure the user can use these features without losing their minds when debugging extensions.</p> <p>To begin with, Ryna is a primarily imperative language, but it also supports many features that would be expected in a functional language, such as first-class functions, lambda expressions and Algebraic Data Types. These features will be explained later, but it's good to know they are supported beforehand. Readers with experience using other functional languages might already realize that these make the language more reliable in general.</p> <p>There are other things that you should take into account, such as the lack of exceptions by design and  the limited support for common algorithms, but these might be either changed in the future or added as an optional library.</p>"},{"location":"pages/tutorial/steps/first/#what-can-you-expect-from-ryna","title":"What can you expect from Ryna?","text":"<p>A mostly working language, but no more for now.</p> <p>This is a one-man passion project and cannot be sustained as a production grade language, so you can expect bugs, the lack of important features and some design flaws. You can open an issue in the repository if you find any of these. In the unlikely case that Ryna catches up, the state  of things may change and support might be expanded.</p>"},{"location":"pages/tutorial/steps/first/#is-there-any-way-to-track-the-development","title":"Is there any way to track the development?","text":"<p>Yes and no. The development cycle is mostly chaotic and depends on how I set priorities on the features and how much free time I have. You can encourage me to work on something by opening an issue. </p>"},{"location":"pages/tutorial/steps/fn_macros/","title":"Function Macros","text":"<p>The final feature that we will be taking a look at is one is arguably one of the most unique: macros. Be aware that a macro in Ryna is not the same as a macro in other languages such as C, C++ or even Rust, even though they are  close to Rust's. The main difference between Rust's macros and Ryna's is that there is no restriction on the syntax that you can match. Let's take a look at how they work by diving into the first kind of macros Ryna has: function macros.</p>"},{"location":"pages/tutorial/steps/fn_macros/#syntax","title":"Syntax","text":"<p>A function macro can be created in Ryna using this syntax:</p> <pre><code>syntax macro_name from NDL_Pattern {\n    [...]\n}\n\n// This is also allowed\nsyntax fn macro_name from NDL_Pattern {\n    [...]\n}\n</code></pre> <p>When you define a macro of this kind you can \"invoke\" it by using the syntax anywhere in your code where an expression is legal. Just be aware that  macros are internally compiled to a different representation. In the case of function macros, they are converted to do blocks:</p> <pre><code>syntax macro_name from \"Macro\" Arg(n, 1{d}) {\n    return $n;\n}\n\n// This macro ...\nprint(Macro5);\n\n// ... is compiled to this\nprint(do { return 5; });\n</code></pre> <p>You may have noticed that the syntax inside a macro body is not the same as a function. This is because the body of a macro is composed of patterns that use <code>Arg</code>s in order to generate code by concatenation. There are a few different types of patterns with varying complexities, but they all generate a piece of text that is concatenated to the one generated by the previous pattern.</p>"},{"location":"pages/tutorial/steps/fn_macros/#macro-patterns","title":"Macro patterns","text":"<p>These are the patterns that you can use inside a macro's body:</p> Pattern Syntax Description Variable <code>$Var</code> Pastes the value of the <code>Arg</code> named <code>Var</code> into the macro result Index <code>$Var.i</code> Pastes the <code>i</code>th value of the <code>Arg</code> named <code>Var</code> into the macro result. <code>i</code> must also be an <code>Arg</code> Loop <code>@Var.i {Pat}</code> Pastes the result of the <code>Pat</code> subpattern creating a variable <code>i</code> with its corresponing index for each element in <code>Var</code> Code <code>{| Pat |}</code> Gets the result of the <code>Pat</code> subpattern and executes the resulting code. Pastes anything that is passed to <code>emit</code> (more information in its own section) Text Anything else Pastes the given text into the macro result <p>In order to be able to write these patterns and disambiguate where the macro ends you may have to escape braces or dots. This is common when writing code patterns, since loops, lambdas and do blocks use braces.</p>"},{"location":"pages/tutorial/steps/fn_macros/#example","title":"Example","text":"<p>Let's see an example where we try to create a macro to initialize an <code>Array</code> statically:</p> <pre><code>syntax array_initialization from \"&lt;\" Arg(&lt;type&gt;, type) \"&gt;[\" [{Arg(&lt;expr&gt;, elems) \",\" [s]} Arg(&lt;expr&gt;, elems)] \"]\" {\n    let res = arr&lt;$type&gt;();\n\n    @elems.i {\n        res.push($elems.i);\n    }\n\n    return move(res);\n}\n</code></pre> <p>This macro allows you to write code such as this:</p> <pre><code>let array = &lt;Int&gt;[1, 2, 3, 4, 5];\n</code></pre> <p>Which will then be compiled to this:</p> <pre><code>let array = do {\n    let res = arr&lt;Int&gt;();\n\n    res.push(1);\n    res.push(2);\n    res.push(3);\n    res.push(4);\n    res.push(5);\n\n    return *res;\n};\n</code></pre> <p>As you can imagine, this allows you to create very complex behaviours transparently. You can see more  complex examples in the Learn by example section.</p>"},{"location":"pages/tutorial/steps/imports/","title":"Importing Modules","text":"<p>An important aspect of every programming language is importing code created before either by you or by someone else. We call these modules in Ryna and you can import code selectively from them. Let's take a look at how.</p>"},{"location":"pages/tutorial/steps/imports/#syntax","title":"Syntax","text":"<p>The syntax we need to use to import modules is as follows:</p> <pre><code>//Import function/s from a module\nimport fn function_name from module_name;\nimport fn {function_name1, function_name2, ...} from module_name;\nimport fn * from module_name;\n\n//Import class/es from a module\nimport class class_name from module_name;\nimport class {class_name1, class_name2, ...} from module_name;\nimport class * from module_name;\n\n//Import interface from a module\nimport interface interface_name from module_name;\nimport interface {interface_name1, interface_name2, ...} from module_name;\nimport interface * from module_name;\n\n//Import syntax (macro) from a module\nimport syntax syntax_name from module_name;\nimport syntax {syntax_name1, syntax_name2, ...} from module_name;\nimport syntax * from module_name;\n\n//Import operators from a module\nimport prefix op \"op\" from module_name;\nimport prefix op {\"op1\", \"op2\", ...} from module_name;\nimport prefix op * from module_name;\n\nimport postfix op \"op\" from module_name;\nimport postfix op {\"op1\", \"op2\", ...} from module_name;\nimport postfix op * from module_name;\n\nimport binary op \"op\" from module_name;\nimport binary op {\"op1\", \"op2\", ...} from module_name;\nimport binary op * from module_name;\n\nimport nary op \"op\" from module_name; // Concatenate open and close symbols for these\nimport nary op {\"op1\", \"op2\", ...} from module_name;\nimport nary op * from module_name;\n\n// Import everything from a module\nimport * from module_name;\n</code></pre> <p>As you can expect, you have to configure the <code>module_name</code> module in your ryna_config.yml before importing it.</p>"},{"location":"pages/tutorial/steps/imports/#local-imports","title":"Local imports","text":"<p>Local imports are a special case that apply when you want to import code from a file that is not main.ryna and is located  inside the project folder (with any number of anidated folders). For this, just use the syntax <code>/folder/of/the/file</code>, where the file is <code>&lt;project_folder&gt;/folder/of/file.ryna</code>. It is important the the path starts with <code>/</code>.</p>"},{"location":"pages/tutorial/steps/interfaces/","title":"Defining Interfaces","text":"<p>Ryna does not allow inheritance-based polymorphism as in most programming languages. Instead, generics are entirely based on bounded template substitution. In order to use this, we need to define interfaces and implement them for out types. In this section we will define the syntax and semantics of this mechanism.</p>"},{"location":"pages/tutorial/steps/interfaces/#about-interfaces","title":"About interfaces","text":"<p>An interface can be defined as a set of function and operation signatures that may or may not be fulfilled by a target type  which is marked as <code>Self</code>. We say that a type <code>T</code> fulfills the interface if every function and operation definition inside the interface exists when we substitute <code>Self</code> by <code>T</code>.</p> <p>Also, when a type fulfills an interface, you can implement it, which means that we mark thye type so that the interpreter knows it and we can make use of bounded substitution on that interface with that type. Implementations can also be parametric.</p>"},{"location":"pages/tutorial/steps/interfaces/#syntax","title":"Syntax","text":"<p>We can define an interface using the following syntax:</p> <pre><code>// Simple\ninterface Example {\n    fn example_1(v: Self);\n    fn example_2(...) -&gt; Type;\n\n    [...]\n\n    op prefix_op (v: TypeV) -&gt; Type;\n\n    [...]\n\n    op (v: TypeV) postfix_op -&gt; Type;\n\n    [...]\n\n    op (a: TypeA) binary_op (b: TypeB) -&gt; Type;\n\n    [...]\n\n    op (a: TypeA) nary_open args nary_close -&gt; Type;\n}\n\n// With generics\ninterface Example&lt;T&gt; {\n    fn example_1(v: Self, n : 'T);\n    fn example_2(...) -&gt; Type;\n\n    [...]\n\n    op prefix_op (v: 'T) -&gt; Type;\n\n    [...]\n\n    op (v: 'T) postfix_op -&gt; Type;\n\n    [...]\n\n    op (a: TypeA) binary_op (b: 'T) -&gt; Type;\n\n    [...]\n\n    op (a: 'T) nary_open args nary_close -&gt; Type;\n}\n</code></pre> <p>Then we can implement it using the following syntax:</p> <pre><code>// Simple\nimplement Example for Type;\n\n// With generics\nimplement Example&lt;OtherType&gt; for Type;\n\n// Generic implementation (define for all arrays)\nimplement&lt;T&gt; Example&lt;OtherType&gt; for Array&lt;'T&gt;;\n</code></pre> <p>If <code>Type</code> does not fulfill <code>Example</code>, the interpreter will raise an error.</p>"},{"location":"pages/tutorial/steps/interfaces/#semantics","title":"Semantics","text":"<p>The best way to understand how this works is with an example. Imagine that you want to create a function that takes an argument of a type that can be converted to <code>Int</code>. You could start by writing this:</p> <pre><code>fn test(n: Int) -&gt; Int {\n    [...]\n}\n</code></pre> <p>This is problematic because you would have to convert everything on call time. To avoid this you could write something like this:</p> <pre><code>// An overload for each supported type\nfn convert(n: Int) -&gt; Int {\n    return n.deref();\n}\n\nfn convert(n: Float) -&gt; Int {\n    return n.floor();\n}\n\n// Use generics\nfn&lt;T&gt; test(n: 'T) -&gt; Int {\n    let converted: Int = convert(n.deref());\n    [...]\n}\n</code></pre> <p>The problem with this approach is that you rely on the <code>convert</code> function being defined for <code>'T</code> and that might not be the case. Even worse, it could be defined with wrong types and cause difficult to debug errors. In order to avoid all this, you can use an interface and bounded substitution:</p> <pre><code>// Define interface\ninterface Convertible {\n    fn convert(n: Self) -&gt; Int;\n}\n\n// An overload for each supported type\nfn convert(n: Int) -&gt; Int {\n    return n.deref();\n}\n\nfn convert(n: Float) -&gt; Int {\n    return n.floor();\n}\n\n// Explicit implementations\nimplement Convertible for Int;\nimplement Convertible for Float;\n\n// Use bounded generics\nfn&lt;T&gt; test(n: 'T [Convertible]) -&gt; Int {\n    let converted: Int = convert(n.deref());\n    [...]\n}\n</code></pre>"},{"location":"pages/tutorial/steps/lambdas/","title":"Lambda Expressions","text":"<p>The main problem with regular functions is that they cannot be passed around, since polymorphism makes it really difficult. In order to have first class functions you have to use lambda expressions. They work like this:</p>"},{"location":"pages/tutorial/steps/lambdas/#syntax","title":"Syntax","text":"<p>The syntax to create lambda expression is as follows:</p> <pre><code>[captures](arg_1: Type_1, arg_2: Type_2, ...) -&gt; ReturnType { \n    [body]    \n};\n\n// With inferred return type\n[captures](arg_1: Type_1, arg_2: Type_2, ...) { \n    [body]    \n};\n\n// Direct return\n[captures](arg_1: Type_1, arg_2: Type_2, ...) expression;\n</code></pre> <p>Captures are optional.</p>"},{"location":"pages/tutorial/steps/lambdas/#using-them","title":"Using them","text":"<p>In terms of functionality, they are the same as regular functions. Here is an example:</p> <pre><code>let double = (i: Int) i * 2;\n\nprint(double(4)); // Prints 8\n</code></pre> <p>If you want to access data outside the context of the lambda expression, you can use captures (you can only capture variables, not expressions):</p> <pre><code>let i = -1;\n\nlet count = [i]() {\n    i.inc();\n    return *i;\n};\n\nlet c0 = count(); // 0\nlet c1 = count(); // 1\nlet c2 = count(); // 2\nlet c3 = count(); // 3\n</code></pre> <p>Of course, you can also pass lambdas as function arguments as long as you use the correct type (see function types).</p>"},{"location":"pages/tutorial/steps/literals/","title":"Literals","text":"<p>One of the main features of Ryna is that it allows the programmer to define many new elements of the syntax. One of these are literals, which can be defined for any valid class. Let's see how this works.</p>"},{"location":"pages/tutorial/steps/literals/#basic-classes","title":"Basic classes","text":"<p>The firt part of this is the syntax of basic types. Not all of them have types, but the ones that do are the basic building blocks for more compplicated literals. Here is a table with the basic types that do have a syntax:</p> Type NDL Pattern Regex <code>Int</code> <code>[\"-\"] 1{d}</code> <code>-?\\d+</code> <code>Float</code> <code>[\"-\"] 1{d} \".\" 1{d}</code> <code>-?\\d+\\.\\d+</code> <code>Bool</code> <code>\"true\" | \"false\"</code> <code>true|false</code> <code>String</code> No constaint <code>.*</code> <p>Everything that follows these syntaxes can be parsed as an instance of this type.</p>"},{"location":"pages/tutorial/steps/literals/#creating-a-literal","title":"Creating a literal","text":"<p>In order to create a new literal you first have to create a new class that the literal will be parsed to. Also, this class's attributes must also have at least a syntax. Here is an example class thaht represents a number of D&amp;D dice rolls: </p> <pre><code>class Dice {\n    rolls: Int;\n    sides: Int;\n}\n\nlet d = Dice(5, 20); // Throw a 20 sided dice 5 times \n</code></pre> <p>Now, the readers that have played D&amp;D know that this value is often represented as <code>5D20</code>. We can define this simple syntax using Ryna:</p> <pre><code>class Dice {\n    syntax from Arg(1{d}, rolls) \"D\" Arg(1{d}, sides);\n\n    rolls: Int;\n    sides: Int;\n}\n\nlet d = 5D20; // Throw a 20 sided dice 5 times \n</code></pre> <p>Here the <code>Arg</code> NDL marker tells the interpreter that the syntax of a <code>Dice</code> consist on an integer (the <code>rolls</code>) followed by a <code>D</code> and, finally, another integer (the <code>sides</code>). After this, the class <code>Dice</code> can also be parsed inside an NDL pattern. Now let's take a look at a different use case: an integer array:</p> <pre><code>class Ints {\n    syntax from \"[\" Arg(1{d}, ints) {\", \" Arg(1{d}, ints)} \"]\";\n\n    ints: Array&lt;Int&gt;;\n}\n\nlet a: Ints = [1, 2, 3];\n</code></pre> <p>This case shows how the interpreter works when an <code>Arg</code> marker with the same target is matched several times. Each time it matches, the result is parsed inside an <code>Array</code> of the type it parses.</p>"},{"location":"pages/tutorial/steps/memory/","title":"Ryna Memory Model","text":"<p>Let's begin this tutorial by talking about something that might be overly thechnical and not necessary: the memory model. I'll provide a short answer for the more experienced readers so they can skip this and go to the next section: Ryna uses reference counting for every value without cycle detection. If you understood what that meant, you are safe to skip  this section, else you should keep reading, even though this can be very intuitive.</p>"},{"location":"pages/tutorial/steps/memory/#data-storage","title":"Data storage","text":"<p>Ryna stores data into Data Blocks that can be referenced by other data blocks:</p> <pre><code>%% mermaid\ngraph LR;\n    A[\"`**Data A**`\"]\n    B[\"`**Data B**`\"]\n    C[\"`**Data C**`\"]\n\n    B--&gt;A;\n    C--&gt;A;\n</code></pre> <p>In this case, <code>Data A</code> is referenced by <code>Data B</code> and <code>Data C</code>. We say that these last two are references.  Every Data Block has a reference counter (RC from now on) that is set to the number of blocks that reference it. The fact that two blocks  are referencing <code>Data A</code> makes it have a RC with that very value:</p> <pre><code>%% mermaid\ngraph LR;\n    A[\"`**Data A** \n    (*RC* 2)`\"]\n    B[\"`**Data B** \n    (*RC* 0)`\"]\n    C[\"`**Data C** \n    (*RC* 0)`\"]\n\n    B--&gt;A;\n    C--&gt;A;\n</code></pre> <p>Now, Data Blocks are initially created with an RC of 0 (as expected) and it is incremented by 1 each time a new Block references it. This is easy, but things get a little more complicated when you start deleting them.</p> <p>The rules used to delete blocks are the following:</p> <ol> <li>A block can only be safely deleted if no other blocks are referencing it.</li> <li>If you try to delete a block whose RC is not 0, it will become an orphan, which is a Block whose data can only be accessed by reference. This makes sense in the context of Ryna.</li> <li>When you safely delete a block, the interpreter decreases the RC of every other block it references by 1. Safely delete any referenced orphan Blocks whose RC reaches 0.</li> </ol> <p>Let's illustrate this with an example. Picture what would happen if we tried to delete <code>Data C</code>. Since its RC is 0, we can safely delete it and decrease the RC of <code>Data A</code> by 1:</p> <pre><code>%% mermaid\ngraph LR;\n    A[\"`**Data A** \n    (*RC* 1)`\"]\n    B[\"`**Data B** \n    (*RC* 0)`\"]\n\n    B--&gt;A;\n</code></pre> <p>Then, if we tried to delete <code>Data A</code>, we would create an orphan Block, allowing the value to still be accessed from <code>Data B</code>:</p> <pre><code>%% mermaid\ngraph LR;\n    A[\"`**Data A** \n    (*RC* 1)\n    *orphan*`\"]\n    B[\"`**Data B** \n    (*RC* 0)`\"]\n\n    B--&gt;A;\n</code></pre> <p>If we tried to delete <code>Data B</code> after that, then we could safely delete it and decrease the RC of <code>Data A</code> to 0. Then <code>Data A</code> would also delete by cascade.</p> <p>While they might seem a little strange, these rules are used in many other languages to allow values inside a program to live for as long as they are referenced. These also eliminate any null dereferencing crashes. But this can also cause some problems if used carelessly.</p>"},{"location":"pages/tutorial/steps/memory/#cyclic-references","title":"Cyclic references","text":"<p>This memory model is very good when it comes to erradicating pesky null references, but it also has the problem that it might allow the  creation of infinite loops. Let's elaborate further.</p> <p>Let's imagine that we have a configuration such as this one:</p> <pre><code>%% mermaid\ngraph LR;\n    A[\"`**Data A** \n    (*RC* 1)`\"]\n    B[\"`**Data B** \n    (*RC* 1)`\"]\n\n    B--&gt;A;\n    A--&gt;B;\n</code></pre> <p>If this is the case, then <code>Data A</code> and <code>Data B</code> cannot be deleted. If we try to delete them in any order we only reach a configuration where both are orphan, but have an RC of 1. This is called a cycle and is not exactly easy to solve. Right now, Ryna allows the creation of these and no warning will be given, so a memory leak can indeed be caused.</p> <p>Having said this, a cycle should not be common unless you are doing some strange coding. It's your choice if you want to abuse  the system, but be warned that this pattern should be avoided.</p> <p>Note: there might be a moment where a full garbage collector is implemented if there is a demand for it, but performance will most likely be affected by it</p> <p>Now we can continue to a less technical section.</p>"},{"location":"pages/tutorial/steps/operators/","title":"Defining Operators","text":"<p>Let's now see how you can define operators and operations in Ryna. The process is always to define the operator and then the operations, so the sections will follow that order. </p>"},{"location":"pages/tutorial/steps/operators/#how-precedence-works","title":"How precedence works","text":"<p>Precedence is an unique integer that tells the interpreter the order in which it has to read operators. Let's take this expression for example:</p> <pre><code>let n = 2 + 3 * 4;\n</code></pre> <p>Is <code>a</code> equal to <code>2 + (3 * 4)</code> or <code>(2 + 3) * 4</code>? In this case it is obvious that the first option is correct, but this might not be as obvious with other operators. We make the interpreter read that expression properly by setting a lower precedence on the <code>*</code> operator compared to <code>+</code>. This  idea can also be naturally be extended to every other type of operator supported by Ryna.</p>"},{"location":"pages/tutorial/steps/operators/#prefix","title":"Prefix","text":"<p>You can define a prefix operator using the following syntax:</p> <pre><code>unary prefix op \"operator_repr\" (precedence);\n</code></pre> <p>Operations are defined as follows:</p> <pre><code>// Simple\nop operator_repr (arg_name: Type) -&gt; Return_type {\n    [...]\n}\n\n// With generics\nop&lt;T&gt; operator_repr (arg_name: Type) -&gt; Return_type {\n    [...]\n}\n\n// Simple usage\nlet var_1 = operator_repr expression;\n\n// Generic usage\nlet var_2 = operator_repr&lt;Type&gt; expression;\n</code></pre>"},{"location":"pages/tutorial/steps/operators/#postfix","title":"Postfix","text":"<p>You can define a postfix operator using the following syntax:</p> <pre><code>unary postfix op \"operator_repr\" (precedence);\n</code></pre> <p>Operations are defined as follows:</p> <pre><code>// Simple\nop (arg_name: Type) operator_repr -&gt; Return_type {\n    [...]\n}\n\n// With generics\nop&lt;T&gt; (arg_name: Type) operator_repr -&gt; Return_type {\n    [...]\n}\n\n// Simple usage\nlet var_1 = expression operator_repr;\n\n// Generic usage\nlet var_2 = expression &lt;Type&gt;operator_repr;\n</code></pre>"},{"location":"pages/tutorial/steps/operators/#binary","title":"Binary","text":"<p>You can define a binary operator using the following syntax:</p> <pre><code>binary op \"operator_repr\" (precedence);\n</code></pre> <p>Alternatively, you can create a right-associative operator using the <code>right</code> keyword: </p> <pre><code>binary right op \"operator_repr\" (precedence);\n</code></pre> <p>Operations are defined as follows:</p> <pre><code>// Simple\nop (arg_name_left: Type_left) operator_repr (arg_name_right: Type_right) -&gt; Return_type {\n    [...]\n}\n\n// With generics\nop&lt;T&gt; (arg_name_left: Type_left) operator_repr (arg_name_right: Type_right) -&gt; Return_type {\n    [...]\n}\n\n// Simple usage\nlet var_1 = expression operator_repr expression;\n\n// Generic usage\nlet var_2 = expression &lt;Type&gt;operator_repr expression;\n</code></pre>"},{"location":"pages/tutorial/steps/operators/#n-ary","title":"N-ary","text":"<p>You can define a nary operator using the following syntax:</p> <pre><code>nary op from \"open_repr\" to \"close_repr\" (precedence);\n</code></pre> <p>Operations are defined as follows:</p> <pre><code>// Simple\nop (arg: Type) open_repr arg_1: Type_1, arg_2: Type_2, ... open_repr -&gt; Return_type {\n    [...]\n}\n\n// With generics\nop&lt;T&gt; (arg: Type) open_repr arg_1: Type_1, arg_2: Type_2, ... open_repr -&gt; Return_type {\n    [...]\n}\n\n// Simple usage\nlet var_1 = expression open_repr expression_1, expression_2, ... close_repr;\n\n// Generic usage\nlet var_2 = expression &lt;Type&gt;open_repr expression_1, expression_2, ... close_repr;\n</code></pre>"},{"location":"pages/tutorial/steps/other/","title":"Other Types","text":"<p>We have seen the most important building blocks for types in the previous sections, but there are three  other types that we have to take into account. These might not come out so often, but are relevant nonetheless.</p>"},{"location":"pages/tutorial/steps/other/#empty-type","title":"Empty type","text":"<p>The empty type <code>()</code> is, technically the type of a tuple with no elements inside it (hence, the name). In Ryna, it is used to represent what other languages call void or, in other words, no value.</p> <p>As you might expect, this comes up in functions that do not return anything. The action of not returning is translated  by the compiler into returning an instance of the empty type.</p>"},{"location":"pages/tutorial/steps/other/#wildcard-type","title":"Wildcard type","text":"<p>Perhaps a more strange type is the wildcard type <code>*</code>. As you might expect it represents an instance of any type at all. Ryna includes it just because it might be useful in case you are trying to build a dynamic dispatch system of any kind and you do not like generics.</p>"},{"location":"pages/tutorial/steps/other/#funtion-types","title":"Funtion types","text":"<p>These types are formed by two parts: the arguments and the return type. A function type represents a function that takes the parameters specified in the arguments and returns the return type. For example, <code>Int =&gt; Float</code> represents a function that takes an <code>Int</code> and returns a <code>Float</code>. Multiple arguments can be specified using product types, so all these are valid function types:</p> <pre><code>(Int, Float) =&gt; Bool\n(Int, *, Int) =&gt; Int\n() =&gt; String          // No arguments \n</code></pre> <p>The only way as of now to create instances of these types is via lambda expressions, but we will talk about them in a later section. Now, let's finally dive into generics.</p>"},{"location":"pages/tutorial/steps/rdl/","title":"Ryna Definition Language","text":"<p>Before we dive into the syntax extension mechanics that Ryna has, we have to take a look at a sublanguage called  Ryna Definition Language (called NDL for short). This sublanguage can be embedded in some parts of your Ryna projects in order to extend the language. Let's see how it works.</p>"},{"location":"pages/tutorial/steps/rdl/#almost-regex","title":"Almost regex","text":"<p>NDL is, as the title suggests, almost a flavour of regexes, but more expressive. This bump in expressiveness comes from its interlinkage with the Ryna parser, which contains many complex routines that cannot be expressed in terms of  regular expressions. </p> <p>The basic idea is simple, a pattern in NDL is a sequence of other subpatterns that have to match a string of characters in sequence. Some of these patters modify the \"flow\" of the matching, but it is more or less the same as a regex. For example, the pattern <code>d</code> matches a digit and the pattern <code>'hello'</code> matches the text \"hello\", but you can also have repeated matches and optional ones.</p>"},{"location":"pages/tutorial/steps/rdl/#patterns","title":"Patterns","text":"<p>Note: this list will probably be expanded in the future due to new patterns</p> <p>The following patterns are defined in the current version on NDL:</p> Name Syntax Description Text <code>\"Text\"</code> Matches the text in double quotes Digit <code>d</code> Matches a digit Lowercase letter <code>l</code> Matches a lowercase letter Uppercase letter <code>L</code> Matches an uppercase letter Alphabetic <code>a</code> Matches an alphabetic character Alphanumeric <code>A</code> Matches an alphanumeric character Space <code>s</code> Matches one or more spacing sequences of characters. These include comments Range <code>[a-b]</code> Matches a character that is between the two given characters Optional <code>[pattern]</code> Matches <code>pattern</code> if possible, succeeds anyways Or <code>pattern1 | pattern2</code> Matches <code>pattern1</code> if possible, else matches <code>pattern2</code> And <code>pattern1 pattern2</code> Matches <code>pattern1</code>, then matches <code>pattern2</code> Repeat <code>min{pattern}max</code> Matches <code>pattern</code>, between <code>min</code> and <code>max</code> times <p>Also, NDL has support for some high level patterns that make use of complex parsing routines. These are the patterns supported as of now:</p> Name Syntax Description Identifier <code>&lt;ident&gt;</code> Matches an identifier Type <code>&lt;type&gt;</code> Matches a type Expression <code>&lt;expr&gt;</code> Matches an expression NDL <code>&lt;rdl&gt;</code> Matches a NDL pattern"},{"location":"pages/tutorial/steps/rdl/#examples","title":"Examples","text":"<p>Here are some examples that may help you to visualize how NDL works:</p> <pre><code>// Integer syntax\n1{d}\n\n// Simple float syntax\n[\"-\"] 1{d} [\".\" 1{d}]\n\n// Variable definition\n\"let\" s &lt;ident&gt; [s] \":\" [s] &lt;type&gt; [s] \"=\" [s] &lt;expr&gt; [s] \";\"\n</code></pre>"},{"location":"pages/tutorial/steps/rdl_macros/","title":"RDL Macros","text":"<p>The final type of macro that we are going to look at is one that allows you to create custom NDL patterns. These are called NDL macros and work like this: </p>"},{"location":"pages/tutorial/steps/rdl_macros/#syntax","title":"Syntax","text":"<p>A NDL macro can be created in Ryna using this syntax:</p> <pre><code>syntax rdl macro_name from NDL_Pattern {\n    [...]\n}\n</code></pre> <p>This macro would have to create a string that can be parsed as an NDL pattern. This syntax can then be used safely inside any implicit class syntax or macro.</p> <p>This would be an example that transforms a pattern into a series of that pattern separated by commas (again, note that we need to escape the closing brace):</p> <pre><code>syntax rdl comma_separated from \"#\" s Arg(&lt;rdl&gt;, inner) s \"#\" {\n    $inner { \", \" $inner \\}\n}\n\n// Usage example\nclass Ints {\n    // This pattern es equivalent to \"[\" Arg(1{d}, ints) {\", \" Arg(1{d}, ints)} \"]\"\n    syntax from \"[\" # Arg(1{d}, ints) # \"]\";\n\n    ints: Array&lt;Int&gt;;\n}\n\nlet a: Ints = [1, 2, 3];\n</code></pre>"},{"location":"pages/tutorial/steps/references/","title":"References","text":"<p>In the Ryna type system, references are the way the language has to make indirect value assotiations. They can be seen as analogous to pointers in languages such as C or C++, but are much safer, since you generally cannot access invalid data.</p> <p>There are two kinds of references in the Ryna type system: </p> <ul> <li>Constant references: they can be used to read the data that they point to, but you cannot modify it under any circumstances.</li> <li>Mutable references: The same as constant ones, but you are allowed to modify or even replace the underlying data.</li> </ul> <p>Now, in order to pointt to something, you need to know what you are pointing to. This is done with other types. When you want to create a constant reference that points to a value of type T, you use the type <code>&amp;T</code>. In a similar way, you use <code>@T</code> for a  mutable reference pointing to a T. You can also construct chained references such as <code>@&amp;T</code>.</p> <p>Using this rule, we could construct types such as <code>&amp;Int</code> or <code>@String</code>, which refer to a constant reference to an <code>Int</code> and a mutable reference to a <code>String</code>, respectively. In the next sections we will see how to create even more complex types.</p>"},{"location":"pages/tutorial/steps/rynaffi/","title":"The Other Side - Rust","text":"<p>The last piece of the puzzle when dealing with interactions with other programming languages is the other side (i.e. the \"native\" language). Ryna is programmed in Rust, so it makes sense for the only library (at the moment) for FFI interactions to be written in that language. We will now see how we can program a very simple  library that uses the ryna-ffi crate to call Rust functions from Ryna.</p>"},{"location":"pages/tutorial/steps/rynaffi/#creating-the-project","title":"Creating the project","text":"<p>We first have to create a Rust project that uses the ryna-ffi crate and that is configured as dynamic library. This is an example Cargo.toml for that project:</p> <pre><code>[package]\nname = \"ryna_ffi_example\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nryna-ffi = \"0.1.0\"\n</code></pre>"},{"location":"pages/tutorial/steps/rynaffi/#creating-functions","title":"Creating functions","text":"<p>Now you can go to your lib.rs and create the functions that you will expose to Ryna. These functions need to have a very specific signature, so a convenience macro is included:</p> <pre><code>use rynaffi::{ryna_ffi_function, FFIArgs, FFIReturn};\n\nryna_ffi_function!(sum_two_floats(args, out) {\n    // The args variable is of type &amp;[FFIValue]\n    let a = args[0].as_f64();\n    let b = args[1].as_f64();\n\n    /*\n        You have to assign a FFIReturn object to \n        the out variable in order to return values to Ryna\n    */\n    unsafe { *out = (a + b).into(); }\n});\n</code></pre> <p>This defines a function called sum_two_floats that, as the name implies, takes two <code>Float</code>s and returns their sum. The parameters of the function are passed as a slice because this makes it easier to define an universal signature. Any other way to define an FFI function may fail unpredictably, so the usage of the previous pattern and convenience methods is highly encouraged. </p> <p>After this, you can run the <code>cargo build --release</code> command to generate a dynamic library inside the target directory</p>"},{"location":"pages/tutorial/steps/rynaffi/#back-to-the-ryna-side","title":"Back to the Ryna side","text":"<p>Now we can use the <code>load_library</code> and <code>get_function</code> functions from Ryna:</p> <pre><code>// Load the library\n// We are assuming that you used the --release flag\nlet lib = load_library(\"path-to-the-project/target/release/ryna_ffi_example\");\nlet fun = lib.demut().get_function(\"sum_two_floats\");\n\n// This returns a value of type *, so you should make a safe wrapper\nlet res = fun.demut().call(10.5, 1.5);\n\n// Prints 12 (more or less, depends on floating point precision)\nprint(res.deref().as&lt;Float&gt;());\n</code></pre> <p>And that is all!</p>"},{"location":"pages/tutorial/steps/rynaffi/#extending-to-more-languages","title":"Extending to more languages","text":"<p>The Ryna interpreter is compatible with any language that supports the C ABI the same way as Rust does. It is technically possible to generate a similar C FFI library for Ryna, I just have not done it. Also, any language that can interact with Rust can also interact with Ryna by means of the already existent ryna-ffi library.</p> <p>If you are interested in making a FFI library for any language and you are having problems please, submit an issue in the official repository and I will be happy to help :)</p>"},{"location":"pages/tutorial/steps/structural/","title":"Structural Types","text":"<p>Finally, before we take a look at the binding rules that tie this type system together, we will explain one last feature that takes algebraic types to the next level: structural types. These allow you to create aliases for types, but these are  allowed to be recursive so you can create data structures from them.</p>"},{"location":"pages/tutorial/steps/structural/#syntax","title":"Syntax","text":"<p>To talk about structural types we need to take a look at the syntax Ryna uses to define them:</p> <pre><code>type Name = AnotherType;\n</code></pre> <p>In this example, <code>Name</code> would be the generated structural type and <code>AnotherType</code> would be the so called alias, which is the \"translation\" of the type <code>Name</code>. Of course, these could also be made using generics: </p> <pre><code>type Name&lt;T1, T2&gt; = AnotherType&lt;'T1, 'T2&gt;;\n</code></pre>"},{"location":"pages/tutorial/steps/structural/#recursive-data-types","title":"Recursive Data Types","text":"<p>This is fine for having shorter names for complex types, but not much else. The power in these comes from allowing recursion. This would be an example of a recursive structure that can encode a binary tree of <code>Int</code>:</p> <pre><code>type BinaryTree = () | (Int, BinaryTree, BinaryTree);\n</code></pre> <p>This is a common introduction to these data types. In this case, a binary tree is either an empty tree (represented by a <code>()</code>)  or an <code>Int</code> followed by two subtrees with the left and right branches. Of course, this is not the only way to construct such  an structure, but it is a valid example.</p> <p>Now that we have seen every feature of the type system we can define the binding rules. </p>"},{"location":"pages/tutorial/steps/templates/","title":"Template-based Generics","text":"<p>One of the most important aspects of the Ryna type system are templates. These allow you to pass types as parameters in order to create other types. This is mainly used in function and class definitions to prevent code repetition. In this section, we will only explain the basic syntax and semantics of templates.</p>"},{"location":"pages/tutorial/steps/templates/#introduction","title":"Introduction","text":"<p>A template can be defined as a placeholder for another type to go into. They allow the programmer to write typed structures such as \"lists of T\", where T is a type with certain properties without the need of rewriting the class for each possible T. The implementation can be a litle more involved, but it pays off as a library writer.</p>"},{"location":"pages/tutorial/steps/templates/#syntax","title":"Syntax","text":"<p>Type templates are specified in the context of structural types, classes, functions and operations. Each of these has their own syntax and diving into the specifics would be outside the scope of the type system, but we will talk about the syntax when templates are already defined.</p> <p>Templates are always represented with an single quote character before an alphanumerical identifier that follows the same rules as class names. Some examples of valid template names would be <code>'Test</code> or <code>'Parameter_1</code>. Names such as <code>'0123</code> or names with non-ASCII characters are not allowed.</p> <p>Now, this is the way to reference a template that has already been defined, but when you have class that depends on one or more templates (i.e. a parametric class), you also have to specify the type parameters when referring to the class. For example, you cannot refer to the <code>Array</code> class without specifying the type of data that goes inside the array as the first (and only in this case) type parameter. These parameters are specified  the same way as in languages such as C++, with angle brackets. These would be some examples:</p> <pre><code>Array&lt;Int&gt;              // Array of Ints\nArray&lt;Float | String&gt;   // Array of either Floats or Strings\nArray&lt;*&gt;                // Array of anything\nArray&lt;'T&gt;               // Array of 'T (only if 'T is in scope)\n</code></pre> <p>Of course, we can define a class with an arbitrary amount of type parameters, but Ryna does not include any with more than one by default. If we had an hypotetical class called <code>HashMap</code> that had two parameters (the type of the key and the type of the value), we could refer to it like this:</p> <pre><code>HashMap&lt;Int, Int&gt;                 // HashMap from Ints to Ints\nHashMap&lt;String, Float | String&gt;   // HashMap from Strings to either Floats or Strings\nHashMap&lt;*, *&gt;                     // HashMap from anything to anything\nHashMap&lt;Bool, 'T&gt;                 // HashMap from Bool to 'T (only if 'T is in scope)\n</code></pre>"},{"location":"pages/tutorial/steps/templates/#semantics","title":"Semantics","text":"<p>Like we said before, a template is not exactly a type, but a placeholder for a type that will be substituted by a proper type later. This is done to prevent manual code repetition and allow the creation of more general code. </p> <p>How this works is pretty simple. Every time you create a parametric class and refer to it anywhere in the code, the interpreter will substitute the parameters automatically for the ones given inside the angle brackets. This can be essentially understood as creating a new class for each distinct instance of a parametric class. This mechanism works exactly the same way for parametric functions, structural types and operations.</p> <p>Of course, the fact that you substitute a type does not mean that the code magically works. In fact, it might fail to compile if you try to call a function  overload that does not exist. The main way to avoid this is bounded substitution via interfaces.</p>"},{"location":"pages/tutorial/steps/templates/#bounded-substitution","title":"Bounded substitution","text":"<p>Note: this works as of now, but syntax will probably change in future releases</p> <p>This mechanism allows the programmer to specify constraints while defining a parametric type instance. One example of why you would want to do this is that <code>HashMap</code> class we discussed earlier. As you might know, a HashMap structure requires keys to be hashable because of how data is stored inside for fast  retrieval, but not all types might be hashable and you would also want to user to know that they have to implement a hashing function for a custom type before they can put it as a HashMap key.</p> <p>This is what interfaces do, they allow you to define APIs and assert whether or not a type follows it or not. If you define an interface called <code>Hashable</code> that checks whether or not the type that implements it (called <code>Self</code>) has a function called <code>hash</code> that takes a <code>Self</code> and returns an <code>Int</code>, you can use it as a constraint for template substitution.</p> <p>This woult be done simply by changing the references to <code>'T</code> inside the class definition to <code>'T [Hashable]</code>, which translates to a T which is Hashable. You can put as many constraints as you want separated by commas and the constraints can also be parametric, following the same syntax rules as types.</p>"}]}